type AggregateCandidate {
  count: Int!
}

type AggregateCenter {
  count: Int!
}

type AggregateCenterExamSession {
  count: Int!
}

type AggregateCenterExamSessionExaminer {
  count: Int!
}

type AggregateCenterExamSessionSpecialty {
  count: Int!
}

type AggregateDivision {
  count: Int!
}

type AggregateEducationType {
  count: Int!
}

type AggregateExam {
  count: Int!
}

type AggregateExaminer {
  count: Int!
}

type AggregateExamSession {
  count: Int!
}

type AggregatePhase {
  count: Int!
}

type AggregatePhaseRank {
  count: Int!
}

type AggregateRank {
  count: Int!
}

type AggregateRegion {
  count: Int!
}

type AggregateRegisterOptionalSubject {
  count: Int!
}

type AggregateRegistration {
  count: Int!
}

type AggregateReport {
  count: Int!
}

type AggregateScore {
  count: Int!
}

type AggregateSession {
  count: Int!
}

type AggregateSpecialty {
  count: Int!
}

type AggregateSubDivision {
  count: Int!
}

type AggregateSubject {
  count: Int!
}

type AggregateSubjectSpecialty {
  count: Int!
}

type AggregateTown {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

type Candidate {
  id: ID!
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String!
  email: String!
  phoneNumb: Int
  dateOfBirth: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  gender: String!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
  user: User!
}

type CandidateConnection {
  pageInfo: PageInfo!
  edges: [CandidateEdge]!
  aggregate: AggregateCandidate!
}

input CandidateCreateInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String!
  email: String!
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String!
  registration: RegistrationCreateManyWithoutCandidateInput
  user: UserCreateOneWithoutCandidateInput!
}

input CandidateCreateOneWithoutRegistrationInput {
  create: CandidateCreateWithoutRegistrationInput
  connect: CandidateWhereUniqueInput
}

input CandidateCreateOneWithoutUserInput {
  create: CandidateCreateWithoutUserInput
  connect: CandidateWhereUniqueInput
}

input CandidateCreateWithoutRegistrationInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String!
  email: String!
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String!
  user: UserCreateOneWithoutCandidateInput!
}

input CandidateCreateWithoutUserInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String!
  email: String!
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String!
  registration: RegistrationCreateManyWithoutCandidateInput
}

type CandidateEdge {
  node: Candidate!
  cursor: String!
}

enum CandidateOrderByInput {
  id_ASC
  id_DESC
  cand1stName_ASC
  cand1stName_DESC
  cand2ndName_ASC
  cand2ndName_DESC
  cand3rdName_ASC
  cand3rdName_DESC
  placeOfBirth_ASC
  placeOfBirth_DESC
  momName_ASC
  momName_DESC
  dadName_ASC
  dadName_DESC
  image_ASC
  image_DESC
  birthCertNumber_ASC
  birthCertNumber_DESC
  candCode_ASC
  candCode_DESC
  email_ASC
  email_DESC
  phoneNumb_ASC
  phoneNumb_DESC
  dateOfBirth_ASC
  dateOfBirth_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  gender_ASC
  gender_DESC
}

type CandidatePreviousValues {
  id: ID!
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String!
  email: String!
  phoneNumb: Int
  dateOfBirth: DateTime
  createdAt: DateTime!
  updatedAt: DateTime!
  gender: String!
}

type CandidateSubscriptionPayload {
  mutation: MutationType!
  node: Candidate
  updatedFields: [String!]
  previousValues: CandidatePreviousValues
}

input CandidateSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CandidateWhereInput
  AND: [CandidateSubscriptionWhereInput!]
  OR: [CandidateSubscriptionWhereInput!]
  NOT: [CandidateSubscriptionWhereInput!]
}

input CandidateUpdateInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String
  registration: RegistrationUpdateManyWithoutCandidateInput
  user: UserUpdateOneRequiredWithoutCandidateInput
}

input CandidateUpdateOneRequiredWithoutRegistrationInput {
  create: CandidateCreateWithoutRegistrationInput
  update: CandidateUpdateWithoutRegistrationDataInput
  upsert: CandidateUpsertWithoutRegistrationInput
  connect: CandidateWhereUniqueInput
}

input CandidateUpdateOneWithoutUserInput {
  create: CandidateCreateWithoutUserInput
  update: CandidateUpdateWithoutUserDataInput
  upsert: CandidateUpsertWithoutUserInput
  delete: Boolean
  disconnect: Boolean
  connect: CandidateWhereUniqueInput
}

input CandidateUpdateWithoutRegistrationDataInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String
  user: UserUpdateOneRequiredWithoutCandidateInput
}

input CandidateUpdateWithoutUserDataInput {
  cand1stName: String
  cand2ndName: String
  cand3rdName: String
  placeOfBirth: String
  momName: String
  dadName: String
  image: String
  birthCertNumber: String
  candCode: String
  email: String
  phoneNumb: Int
  dateOfBirth: DateTime
  gender: String
  registration: RegistrationUpdateManyWithoutCandidateInput
}

input CandidateUpsertWithoutRegistrationInput {
  update: CandidateUpdateWithoutRegistrationDataInput!
  create: CandidateCreateWithoutRegistrationInput!
}

input CandidateUpsertWithoutUserInput {
  update: CandidateUpdateWithoutUserDataInput!
  create: CandidateCreateWithoutUserInput!
}

input CandidateWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  cand1stName: String
  cand1stName_not: String
  cand1stName_in: [String!]
  cand1stName_not_in: [String!]
  cand1stName_lt: String
  cand1stName_lte: String
  cand1stName_gt: String
  cand1stName_gte: String
  cand1stName_contains: String
  cand1stName_not_contains: String
  cand1stName_starts_with: String
  cand1stName_not_starts_with: String
  cand1stName_ends_with: String
  cand1stName_not_ends_with: String
  cand2ndName: String
  cand2ndName_not: String
  cand2ndName_in: [String!]
  cand2ndName_not_in: [String!]
  cand2ndName_lt: String
  cand2ndName_lte: String
  cand2ndName_gt: String
  cand2ndName_gte: String
  cand2ndName_contains: String
  cand2ndName_not_contains: String
  cand2ndName_starts_with: String
  cand2ndName_not_starts_with: String
  cand2ndName_ends_with: String
  cand2ndName_not_ends_with: String
  cand3rdName: String
  cand3rdName_not: String
  cand3rdName_in: [String!]
  cand3rdName_not_in: [String!]
  cand3rdName_lt: String
  cand3rdName_lte: String
  cand3rdName_gt: String
  cand3rdName_gte: String
  cand3rdName_contains: String
  cand3rdName_not_contains: String
  cand3rdName_starts_with: String
  cand3rdName_not_starts_with: String
  cand3rdName_ends_with: String
  cand3rdName_not_ends_with: String
  placeOfBirth: String
  placeOfBirth_not: String
  placeOfBirth_in: [String!]
  placeOfBirth_not_in: [String!]
  placeOfBirth_lt: String
  placeOfBirth_lte: String
  placeOfBirth_gt: String
  placeOfBirth_gte: String
  placeOfBirth_contains: String
  placeOfBirth_not_contains: String
  placeOfBirth_starts_with: String
  placeOfBirth_not_starts_with: String
  placeOfBirth_ends_with: String
  placeOfBirth_not_ends_with: String
  momName: String
  momName_not: String
  momName_in: [String!]
  momName_not_in: [String!]
  momName_lt: String
  momName_lte: String
  momName_gt: String
  momName_gte: String
  momName_contains: String
  momName_not_contains: String
  momName_starts_with: String
  momName_not_starts_with: String
  momName_ends_with: String
  momName_not_ends_with: String
  dadName: String
  dadName_not: String
  dadName_in: [String!]
  dadName_not_in: [String!]
  dadName_lt: String
  dadName_lte: String
  dadName_gt: String
  dadName_gte: String
  dadName_contains: String
  dadName_not_contains: String
  dadName_starts_with: String
  dadName_not_starts_with: String
  dadName_ends_with: String
  dadName_not_ends_with: String
  image: String
  image_not: String
  image_in: [String!]
  image_not_in: [String!]
  image_lt: String
  image_lte: String
  image_gt: String
  image_gte: String
  image_contains: String
  image_not_contains: String
  image_starts_with: String
  image_not_starts_with: String
  image_ends_with: String
  image_not_ends_with: String
  birthCertNumber: String
  birthCertNumber_not: String
  birthCertNumber_in: [String!]
  birthCertNumber_not_in: [String!]
  birthCertNumber_lt: String
  birthCertNumber_lte: String
  birthCertNumber_gt: String
  birthCertNumber_gte: String
  birthCertNumber_contains: String
  birthCertNumber_not_contains: String
  birthCertNumber_starts_with: String
  birthCertNumber_not_starts_with: String
  birthCertNumber_ends_with: String
  birthCertNumber_not_ends_with: String
  candCode: String
  candCode_not: String
  candCode_in: [String!]
  candCode_not_in: [String!]
  candCode_lt: String
  candCode_lte: String
  candCode_gt: String
  candCode_gte: String
  candCode_contains: String
  candCode_not_contains: String
  candCode_starts_with: String
  candCode_not_starts_with: String
  candCode_ends_with: String
  candCode_not_ends_with: String
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phoneNumb: Int
  phoneNumb_not: Int
  phoneNumb_in: [Int!]
  phoneNumb_not_in: [Int!]
  phoneNumb_lt: Int
  phoneNumb_lte: Int
  phoneNumb_gt: Int
  phoneNumb_gte: Int
  dateOfBirth: DateTime
  dateOfBirth_not: DateTime
  dateOfBirth_in: [DateTime!]
  dateOfBirth_not_in: [DateTime!]
  dateOfBirth_lt: DateTime
  dateOfBirth_lte: DateTime
  dateOfBirth_gt: DateTime
  dateOfBirth_gte: DateTime
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  user: UserWhereInput
  AND: [CandidateWhereInput!]
  OR: [CandidateWhereInput!]
  NOT: [CandidateWhereInput!]
}

input CandidateWhereUniqueInput {
  id: ID
  candCode: String
  email: String
}

type Center {
  id: ID!
  centerName: String!
  centerCode: String!
  centerSecretCode: String!
  town: Town!
  centerNumber: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
  centerExamSessionExaminer(where: CenterExamSessionExaminerWhereInput, orderBy: CenterExamSessionExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionExaminer!]
  centerExamSession(where: CenterExamSessionWhereInput, orderBy: CenterExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSession!]
}

type CenterConnection {
  pageInfo: PageInfo!
  edges: [CenterEdge]!
  aggregate: AggregateCenter!
}

input CenterCreateInput {
  centerName: String!
  centerCode: String!
  centerSecretCode: String!
  town: TownCreateOneWithoutCenterInput!
  centerNumber: Int!
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyInput
  centerExamSession: CenterExamSessionCreateManyWithoutCenterInput
}

input CenterCreateManyWithoutTownInput {
  create: [CenterCreateWithoutTownInput!]
  connect: [CenterWhereUniqueInput!]
}

input CenterCreateOneWithoutCenterExamSessionInput {
  create: CenterCreateWithoutCenterExamSessionInput
  connect: CenterWhereUniqueInput
}

input CenterCreateWithoutCenterExamSessionInput {
  centerName: String!
  centerCode: String!
  centerSecretCode: String!
  town: TownCreateOneWithoutCenterInput!
  centerNumber: Int!
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyInput
}

input CenterCreateWithoutTownInput {
  centerName: String!
  centerCode: String!
  centerSecretCode: String!
  centerNumber: Int!
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyInput
  centerExamSession: CenterExamSessionCreateManyWithoutCenterInput
}

type CenterEdge {
  node: Center!
  cursor: String!
}

type CenterExamSession {
  id: ID!
  examSession: ExamSession!
  center: Center!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
  centerExamSessionSpecialty(where: CenterExamSessionSpecialtyWhereInput, orderBy: CenterExamSessionSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionSpecialty!]
  createdAt: DateTime!
  updatedAt: DateTime!
  centerExamSessionExaminer(where: CenterExamSessionExaminerWhereInput, orderBy: CenterExamSessionExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionExaminer!]
}

type CenterExamSessionConnection {
  pageInfo: PageInfo!
  edges: [CenterExamSessionEdge]!
  aggregate: AggregateCenterExamSession!
}

input CenterExamSessionCreateInput {
  examSession: ExamSessionCreateOneWithoutCenterExamSessionInput!
  center: CenterCreateOneWithoutCenterExamSessionInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput
}

input CenterExamSessionCreateManyWithoutCenterInput {
  create: [CenterExamSessionCreateWithoutCenterInput!]
  connect: [CenterExamSessionWhereUniqueInput!]
}

input CenterExamSessionCreateManyWithoutExamSessionInput {
  create: [CenterExamSessionCreateWithoutExamSessionInput!]
  connect: [CenterExamSessionWhereUniqueInput!]
}

input CenterExamSessionCreateOneWithoutCenterExamSessionExaminerInput {
  create: CenterExamSessionCreateWithoutCenterExamSessionExaminerInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionCreateOneWithoutCenterExamSessionSpecialtyInput {
  create: CenterExamSessionCreateWithoutCenterExamSessionSpecialtyInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionCreateOneWithoutRegistrationInput {
  create: CenterExamSessionCreateWithoutRegistrationInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionCreateWithoutCenterExamSessionExaminerInput {
  examSession: ExamSessionCreateOneWithoutCenterExamSessionInput!
  center: CenterCreateOneWithoutCenterExamSessionInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput
}

input CenterExamSessionCreateWithoutCenterExamSessionSpecialtyInput {
  examSession: ExamSessionCreateOneWithoutCenterExamSessionInput!
  center: CenterCreateOneWithoutCenterExamSessionInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput
}

input CenterExamSessionCreateWithoutCenterInput {
  examSession: ExamSessionCreateOneWithoutCenterExamSessionInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput
}

input CenterExamSessionCreateWithoutExamSessionInput {
  center: CenterCreateOneWithoutCenterExamSessionInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput
}

input CenterExamSessionCreateWithoutRegistrationInput {
  examSession: ExamSessionCreateOneWithoutCenterExamSessionInput!
  center: CenterCreateOneWithoutCenterExamSessionInput!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput
}

type CenterExamSessionEdge {
  node: CenterExamSession!
  cursor: String!
}

type CenterExamSessionExaminer {
  id: ID!
  examiner: Examiner!
  centerExamSession: CenterExamSession!
  phaseRank: PhaseRank!
  createdAt: DateTime!
  updatedAt: DateTime!
  report(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report!]
}

type CenterExamSessionExaminerConnection {
  pageInfo: PageInfo!
  edges: [CenterExamSessionExaminerEdge]!
  aggregate: AggregateCenterExamSessionExaminer!
}

input CenterExamSessionExaminerCreateInput {
  examiner: ExaminerCreateOneInput!
  centerExamSession: CenterExamSessionCreateOneWithoutCenterExamSessionExaminerInput!
  phaseRank: PhaseRankCreateOneInput!
  report: ReportCreateManyWithoutCenterExamSessionExaminerInput
}

input CenterExamSessionExaminerCreateManyInput {
  create: [CenterExamSessionExaminerCreateInput!]
  connect: [CenterExamSessionExaminerWhereUniqueInput!]
}

input CenterExamSessionExaminerCreateManyWithoutCenterExamSessionInput {
  create: [CenterExamSessionExaminerCreateWithoutCenterExamSessionInput!]
  connect: [CenterExamSessionExaminerWhereUniqueInput!]
}

input CenterExamSessionExaminerCreateOneWithoutReportInput {
  create: CenterExamSessionExaminerCreateWithoutReportInput
  connect: CenterExamSessionExaminerWhereUniqueInput
}

input CenterExamSessionExaminerCreateWithoutCenterExamSessionInput {
  examiner: ExaminerCreateOneInput!
  phaseRank: PhaseRankCreateOneInput!
  report: ReportCreateManyWithoutCenterExamSessionExaminerInput
}

input CenterExamSessionExaminerCreateWithoutReportInput {
  examiner: ExaminerCreateOneInput!
  centerExamSession: CenterExamSessionCreateOneWithoutCenterExamSessionExaminerInput!
  phaseRank: PhaseRankCreateOneInput!
}

type CenterExamSessionExaminerEdge {
  node: CenterExamSessionExaminer!
  cursor: String!
}

enum CenterExamSessionExaminerOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CenterExamSessionExaminerPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CenterExamSessionExaminerSubscriptionPayload {
  mutation: MutationType!
  node: CenterExamSessionExaminer
  updatedFields: [String!]
  previousValues: CenterExamSessionExaminerPreviousValues
}

input CenterExamSessionExaminerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CenterExamSessionExaminerWhereInput
  AND: [CenterExamSessionExaminerSubscriptionWhereInput!]
  OR: [CenterExamSessionExaminerSubscriptionWhereInput!]
  NOT: [CenterExamSessionExaminerSubscriptionWhereInput!]
}

input CenterExamSessionExaminerUpdateDataInput {
  examiner: ExaminerUpdateOneRequiredInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionExaminerInput
  phaseRank: PhaseRankUpdateOneRequiredInput
  report: ReportUpdateManyWithoutCenterExamSessionExaminerInput
}

input CenterExamSessionExaminerUpdateInput {
  examiner: ExaminerUpdateOneRequiredInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionExaminerInput
  phaseRank: PhaseRankUpdateOneRequiredInput
  report: ReportUpdateManyWithoutCenterExamSessionExaminerInput
}

input CenterExamSessionExaminerUpdateManyInput {
  create: [CenterExamSessionExaminerCreateInput!]
  delete: [CenterExamSessionExaminerWhereUniqueInput!]
  connect: [CenterExamSessionExaminerWhereUniqueInput!]
  disconnect: [CenterExamSessionExaminerWhereUniqueInput!]
  update: [CenterExamSessionExaminerUpdateWithWhereUniqueNestedInput!]
  upsert: [CenterExamSessionExaminerUpsertWithWhereUniqueNestedInput!]
}

input CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput {
  create: [CenterExamSessionExaminerCreateWithoutCenterExamSessionInput!]
  delete: [CenterExamSessionExaminerWhereUniqueInput!]
  connect: [CenterExamSessionExaminerWhereUniqueInput!]
  disconnect: [CenterExamSessionExaminerWhereUniqueInput!]
  update: [CenterExamSessionExaminerUpdateWithWhereUniqueWithoutCenterExamSessionInput!]
  upsert: [CenterExamSessionExaminerUpsertWithWhereUniqueWithoutCenterExamSessionInput!]
}

input CenterExamSessionExaminerUpdateOneRequiredWithoutReportInput {
  create: CenterExamSessionExaminerCreateWithoutReportInput
  update: CenterExamSessionExaminerUpdateWithoutReportDataInput
  upsert: CenterExamSessionExaminerUpsertWithoutReportInput
  connect: CenterExamSessionExaminerWhereUniqueInput
}

input CenterExamSessionExaminerUpdateWithoutCenterExamSessionDataInput {
  examiner: ExaminerUpdateOneRequiredInput
  phaseRank: PhaseRankUpdateOneRequiredInput
  report: ReportUpdateManyWithoutCenterExamSessionExaminerInput
}

input CenterExamSessionExaminerUpdateWithoutReportDataInput {
  examiner: ExaminerUpdateOneRequiredInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionExaminerInput
  phaseRank: PhaseRankUpdateOneRequiredInput
}

input CenterExamSessionExaminerUpdateWithWhereUniqueNestedInput {
  where: CenterExamSessionExaminerWhereUniqueInput!
  data: CenterExamSessionExaminerUpdateDataInput!
}

input CenterExamSessionExaminerUpdateWithWhereUniqueWithoutCenterExamSessionInput {
  where: CenterExamSessionExaminerWhereUniqueInput!
  data: CenterExamSessionExaminerUpdateWithoutCenterExamSessionDataInput!
}

input CenterExamSessionExaminerUpsertWithoutReportInput {
  update: CenterExamSessionExaminerUpdateWithoutReportDataInput!
  create: CenterExamSessionExaminerCreateWithoutReportInput!
}

input CenterExamSessionExaminerUpsertWithWhereUniqueNestedInput {
  where: CenterExamSessionExaminerWhereUniqueInput!
  update: CenterExamSessionExaminerUpdateDataInput!
  create: CenterExamSessionExaminerCreateInput!
}

input CenterExamSessionExaminerUpsertWithWhereUniqueWithoutCenterExamSessionInput {
  where: CenterExamSessionExaminerWhereUniqueInput!
  update: CenterExamSessionExaminerUpdateWithoutCenterExamSessionDataInput!
  create: CenterExamSessionExaminerCreateWithoutCenterExamSessionInput!
}

input CenterExamSessionExaminerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examiner: ExaminerWhereInput
  centerExamSession: CenterExamSessionWhereInput
  phaseRank: PhaseRankWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  report_every: ReportWhereInput
  report_some: ReportWhereInput
  report_none: ReportWhereInput
  AND: [CenterExamSessionExaminerWhereInput!]
  OR: [CenterExamSessionExaminerWhereInput!]
  NOT: [CenterExamSessionExaminerWhereInput!]
}

input CenterExamSessionExaminerWhereUniqueInput {
  id: ID
}

enum CenterExamSessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CenterExamSessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CenterExamSessionSpecialty {
  id: ID!
  centerExamSession: CenterExamSession!
  specialty: Specialty!
  createdAt: DateTime!
  updatedAt: DateTime!
  registration(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration!]
}

type CenterExamSessionSpecialtyConnection {
  pageInfo: PageInfo!
  edges: [CenterExamSessionSpecialtyEdge]!
  aggregate: AggregateCenterExamSessionSpecialty!
}

input CenterExamSessionSpecialtyCreateInput {
  centerExamSession: CenterExamSessionCreateOneWithoutCenterExamSessionSpecialtyInput!
  specialty: SpecialtyCreateOneWithoutCenterExamSessionSpecialtyInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyCreateManyWithoutCenterExamSessionInput {
  create: [CenterExamSessionSpecialtyCreateWithoutCenterExamSessionInput!]
  connect: [CenterExamSessionSpecialtyWhereUniqueInput!]
}

input CenterExamSessionSpecialtyCreateManyWithoutSpecialtyInput {
  create: [CenterExamSessionSpecialtyCreateWithoutSpecialtyInput!]
  connect: [CenterExamSessionSpecialtyWhereUniqueInput!]
}

input CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput {
  create: CenterExamSessionSpecialtyCreateWithoutRegistrationInput
  connect: CenterExamSessionSpecialtyWhereUniqueInput
}

input CenterExamSessionSpecialtyCreateWithoutCenterExamSessionInput {
  specialty: SpecialtyCreateOneWithoutCenterExamSessionSpecialtyInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyCreateWithoutRegistrationInput {
  centerExamSession: CenterExamSessionCreateOneWithoutCenterExamSessionSpecialtyInput!
  specialty: SpecialtyCreateOneWithoutCenterExamSessionSpecialtyInput!
}

input CenterExamSessionSpecialtyCreateWithoutSpecialtyInput {
  centerExamSession: CenterExamSessionCreateOneWithoutCenterExamSessionSpecialtyInput!
  registration: RegistrationCreateManyWithoutCenterExamSessionSpecialtyInput
}

type CenterExamSessionSpecialtyEdge {
  node: CenterExamSessionSpecialty!
  cursor: String!
}

enum CenterExamSessionSpecialtyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CenterExamSessionSpecialtyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CenterExamSessionSpecialtySubscriptionPayload {
  mutation: MutationType!
  node: CenterExamSessionSpecialty
  updatedFields: [String!]
  previousValues: CenterExamSessionSpecialtyPreviousValues
}

input CenterExamSessionSpecialtySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CenterExamSessionSpecialtyWhereInput
  AND: [CenterExamSessionSpecialtySubscriptionWhereInput!]
  OR: [CenterExamSessionSpecialtySubscriptionWhereInput!]
  NOT: [CenterExamSessionSpecialtySubscriptionWhereInput!]
}

input CenterExamSessionSpecialtyUpdateInput {
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
  specialty: SpecialtyUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput {
  create: [CenterExamSessionSpecialtyCreateWithoutCenterExamSessionInput!]
  delete: [CenterExamSessionSpecialtyWhereUniqueInput!]
  connect: [CenterExamSessionSpecialtyWhereUniqueInput!]
  disconnect: [CenterExamSessionSpecialtyWhereUniqueInput!]
  update: [CenterExamSessionSpecialtyUpdateWithWhereUniqueWithoutCenterExamSessionInput!]
  upsert: [CenterExamSessionSpecialtyUpsertWithWhereUniqueWithoutCenterExamSessionInput!]
}

input CenterExamSessionSpecialtyUpdateManyWithoutSpecialtyInput {
  create: [CenterExamSessionSpecialtyCreateWithoutSpecialtyInput!]
  delete: [CenterExamSessionSpecialtyWhereUniqueInput!]
  connect: [CenterExamSessionSpecialtyWhereUniqueInput!]
  disconnect: [CenterExamSessionSpecialtyWhereUniqueInput!]
  update: [CenterExamSessionSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput!]
  upsert: [CenterExamSessionSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput!]
}

input CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput {
  create: CenterExamSessionSpecialtyCreateWithoutRegistrationInput
  update: CenterExamSessionSpecialtyUpdateWithoutRegistrationDataInput
  upsert: CenterExamSessionSpecialtyUpsertWithoutRegistrationInput
  connect: CenterExamSessionSpecialtyWhereUniqueInput
}

input CenterExamSessionSpecialtyUpdateWithoutCenterExamSessionDataInput {
  specialty: SpecialtyUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyUpdateWithoutRegistrationDataInput {
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
  specialty: SpecialtyUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyUpdateWithoutSpecialtyDataInput {
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionSpecialtyInput
}

input CenterExamSessionSpecialtyUpdateWithWhereUniqueWithoutCenterExamSessionInput {
  where: CenterExamSessionSpecialtyWhereUniqueInput!
  data: CenterExamSessionSpecialtyUpdateWithoutCenterExamSessionDataInput!
}

input CenterExamSessionSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput {
  where: CenterExamSessionSpecialtyWhereUniqueInput!
  data: CenterExamSessionSpecialtyUpdateWithoutSpecialtyDataInput!
}

input CenterExamSessionSpecialtyUpsertWithoutRegistrationInput {
  update: CenterExamSessionSpecialtyUpdateWithoutRegistrationDataInput!
  create: CenterExamSessionSpecialtyCreateWithoutRegistrationInput!
}

input CenterExamSessionSpecialtyUpsertWithWhereUniqueWithoutCenterExamSessionInput {
  where: CenterExamSessionSpecialtyWhereUniqueInput!
  update: CenterExamSessionSpecialtyUpdateWithoutCenterExamSessionDataInput!
  create: CenterExamSessionSpecialtyCreateWithoutCenterExamSessionInput!
}

input CenterExamSessionSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput {
  where: CenterExamSessionSpecialtyWhereUniqueInput!
  update: CenterExamSessionSpecialtyUpdateWithoutSpecialtyDataInput!
  create: CenterExamSessionSpecialtyCreateWithoutSpecialtyInput!
}

input CenterExamSessionSpecialtyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  centerExamSession: CenterExamSessionWhereInput
  specialty: SpecialtyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  AND: [CenterExamSessionSpecialtyWhereInput!]
  OR: [CenterExamSessionSpecialtyWhereInput!]
  NOT: [CenterExamSessionSpecialtyWhereInput!]
}

input CenterExamSessionSpecialtyWhereUniqueInput {
  id: ID
}

type CenterExamSessionSubscriptionPayload {
  mutation: MutationType!
  node: CenterExamSession
  updatedFields: [String!]
  previousValues: CenterExamSessionPreviousValues
}

input CenterExamSessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CenterExamSessionWhereInput
  AND: [CenterExamSessionSubscriptionWhereInput!]
  OR: [CenterExamSessionSubscriptionWhereInput!]
  NOT: [CenterExamSessionSubscriptionWhereInput!]
}

input CenterExamSessionUpdateInput {
  examSession: ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput
  center: CenterUpdateOneRequiredWithoutCenterExamSessionInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateManyWithoutCenterInput {
  create: [CenterExamSessionCreateWithoutCenterInput!]
  delete: [CenterExamSessionWhereUniqueInput!]
  connect: [CenterExamSessionWhereUniqueInput!]
  disconnect: [CenterExamSessionWhereUniqueInput!]
  update: [CenterExamSessionUpdateWithWhereUniqueWithoutCenterInput!]
  upsert: [CenterExamSessionUpsertWithWhereUniqueWithoutCenterInput!]
}

input CenterExamSessionUpdateManyWithoutExamSessionInput {
  create: [CenterExamSessionCreateWithoutExamSessionInput!]
  delete: [CenterExamSessionWhereUniqueInput!]
  connect: [CenterExamSessionWhereUniqueInput!]
  disconnect: [CenterExamSessionWhereUniqueInput!]
  update: [CenterExamSessionUpdateWithWhereUniqueWithoutExamSessionInput!]
  upsert: [CenterExamSessionUpsertWithWhereUniqueWithoutExamSessionInput!]
}

input CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionExaminerInput {
  create: CenterExamSessionCreateWithoutCenterExamSessionExaminerInput
  update: CenterExamSessionUpdateWithoutCenterExamSessionExaminerDataInput
  upsert: CenterExamSessionUpsertWithoutCenterExamSessionExaminerInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput {
  create: CenterExamSessionCreateWithoutCenterExamSessionSpecialtyInput
  update: CenterExamSessionUpdateWithoutCenterExamSessionSpecialtyDataInput
  upsert: CenterExamSessionUpsertWithoutCenterExamSessionSpecialtyInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionUpdateOneRequiredWithoutRegistrationInput {
  create: CenterExamSessionCreateWithoutRegistrationInput
  update: CenterExamSessionUpdateWithoutRegistrationDataInput
  upsert: CenterExamSessionUpsertWithoutRegistrationInput
  connect: CenterExamSessionWhereUniqueInput
}

input CenterExamSessionUpdateWithoutCenterDataInput {
  examSession: ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateWithoutCenterExamSessionExaminerDataInput {
  examSession: ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput
  center: CenterUpdateOneRequiredWithoutCenterExamSessionInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateWithoutCenterExamSessionSpecialtyDataInput {
  examSession: ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput
  center: CenterUpdateOneRequiredWithoutCenterExamSessionInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateWithoutExamSessionDataInput {
  center: CenterUpdateOneRequiredWithoutCenterExamSessionInput
  registration: RegistrationUpdateManyWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateWithoutRegistrationDataInput {
  examSession: ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput
  center: CenterUpdateOneRequiredWithoutCenterExamSessionInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutCenterExamSessionInput
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyWithoutCenterExamSessionInput
}

input CenterExamSessionUpdateWithWhereUniqueWithoutCenterInput {
  where: CenterExamSessionWhereUniqueInput!
  data: CenterExamSessionUpdateWithoutCenterDataInput!
}

input CenterExamSessionUpdateWithWhereUniqueWithoutExamSessionInput {
  where: CenterExamSessionWhereUniqueInput!
  data: CenterExamSessionUpdateWithoutExamSessionDataInput!
}

input CenterExamSessionUpsertWithoutCenterExamSessionExaminerInput {
  update: CenterExamSessionUpdateWithoutCenterExamSessionExaminerDataInput!
  create: CenterExamSessionCreateWithoutCenterExamSessionExaminerInput!
}

input CenterExamSessionUpsertWithoutCenterExamSessionSpecialtyInput {
  update: CenterExamSessionUpdateWithoutCenterExamSessionSpecialtyDataInput!
  create: CenterExamSessionCreateWithoutCenterExamSessionSpecialtyInput!
}

input CenterExamSessionUpsertWithoutRegistrationInput {
  update: CenterExamSessionUpdateWithoutRegistrationDataInput!
  create: CenterExamSessionCreateWithoutRegistrationInput!
}

input CenterExamSessionUpsertWithWhereUniqueWithoutCenterInput {
  where: CenterExamSessionWhereUniqueInput!
  update: CenterExamSessionUpdateWithoutCenterDataInput!
  create: CenterExamSessionCreateWithoutCenterInput!
}

input CenterExamSessionUpsertWithWhereUniqueWithoutExamSessionInput {
  where: CenterExamSessionWhereUniqueInput!
  update: CenterExamSessionUpdateWithoutExamSessionDataInput!
  create: CenterExamSessionCreateWithoutExamSessionInput!
}

input CenterExamSessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examSession: ExamSessionWhereInput
  center: CenterWhereInput
  registration_every: RegistrationWhereInput
  registration_some: RegistrationWhereInput
  registration_none: RegistrationWhereInput
  centerExamSessionSpecialty_every: CenterExamSessionSpecialtyWhereInput
  centerExamSessionSpecialty_some: CenterExamSessionSpecialtyWhereInput
  centerExamSessionSpecialty_none: CenterExamSessionSpecialtyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  centerExamSessionExaminer_every: CenterExamSessionExaminerWhereInput
  centerExamSessionExaminer_some: CenterExamSessionExaminerWhereInput
  centerExamSessionExaminer_none: CenterExamSessionExaminerWhereInput
  AND: [CenterExamSessionWhereInput!]
  OR: [CenterExamSessionWhereInput!]
  NOT: [CenterExamSessionWhereInput!]
}

input CenterExamSessionWhereUniqueInput {
  id: ID
}

enum CenterOrderByInput {
  id_ASC
  id_DESC
  centerName_ASC
  centerName_DESC
  centerCode_ASC
  centerCode_DESC
  centerSecretCode_ASC
  centerSecretCode_DESC
  centerNumber_ASC
  centerNumber_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type CenterPreviousValues {
  id: ID!
  centerName: String!
  centerCode: String!
  centerSecretCode: String!
  centerNumber: Int!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type CenterSubscriptionPayload {
  mutation: MutationType!
  node: Center
  updatedFields: [String!]
  previousValues: CenterPreviousValues
}

input CenterSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: CenterWhereInput
  AND: [CenterSubscriptionWhereInput!]
  OR: [CenterSubscriptionWhereInput!]
  NOT: [CenterSubscriptionWhereInput!]
}

input CenterUpdateInput {
  centerName: String
  centerCode: String
  centerSecretCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyInput
  centerExamSession: CenterExamSessionUpdateManyWithoutCenterInput
}

input CenterUpdateManyWithoutTownInput {
  create: [CenterCreateWithoutTownInput!]
  delete: [CenterWhereUniqueInput!]
  connect: [CenterWhereUniqueInput!]
  disconnect: [CenterWhereUniqueInput!]
  update: [CenterUpdateWithWhereUniqueWithoutTownInput!]
  upsert: [CenterUpsertWithWhereUniqueWithoutTownInput!]
}

input CenterUpdateOneRequiredWithoutCenterExamSessionInput {
  create: CenterCreateWithoutCenterExamSessionInput
  update: CenterUpdateWithoutCenterExamSessionDataInput
  upsert: CenterUpsertWithoutCenterExamSessionInput
  connect: CenterWhereUniqueInput
}

input CenterUpdateWithoutCenterExamSessionDataInput {
  centerName: String
  centerCode: String
  centerSecretCode: String
  town: TownUpdateOneRequiredWithoutCenterInput
  centerNumber: Int
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyInput
}

input CenterUpdateWithoutTownDataInput {
  centerName: String
  centerCode: String
  centerSecretCode: String
  centerNumber: Int
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateManyInput
  centerExamSession: CenterExamSessionUpdateManyWithoutCenterInput
}

input CenterUpdateWithWhereUniqueWithoutTownInput {
  where: CenterWhereUniqueInput!
  data: CenterUpdateWithoutTownDataInput!
}

input CenterUpsertWithoutCenterExamSessionInput {
  update: CenterUpdateWithoutCenterExamSessionDataInput!
  create: CenterCreateWithoutCenterExamSessionInput!
}

input CenterUpsertWithWhereUniqueWithoutTownInput {
  where: CenterWhereUniqueInput!
  update: CenterUpdateWithoutTownDataInput!
  create: CenterCreateWithoutTownInput!
}

input CenterWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  centerName: String
  centerName_not: String
  centerName_in: [String!]
  centerName_not_in: [String!]
  centerName_lt: String
  centerName_lte: String
  centerName_gt: String
  centerName_gte: String
  centerName_contains: String
  centerName_not_contains: String
  centerName_starts_with: String
  centerName_not_starts_with: String
  centerName_ends_with: String
  centerName_not_ends_with: String
  centerCode: String
  centerCode_not: String
  centerCode_in: [String!]
  centerCode_not_in: [String!]
  centerCode_lt: String
  centerCode_lte: String
  centerCode_gt: String
  centerCode_gte: String
  centerCode_contains: String
  centerCode_not_contains: String
  centerCode_starts_with: String
  centerCode_not_starts_with: String
  centerCode_ends_with: String
  centerCode_not_ends_with: String
  centerSecretCode: String
  centerSecretCode_not: String
  centerSecretCode_in: [String!]
  centerSecretCode_not_in: [String!]
  centerSecretCode_lt: String
  centerSecretCode_lte: String
  centerSecretCode_gt: String
  centerSecretCode_gte: String
  centerSecretCode_contains: String
  centerSecretCode_not_contains: String
  centerSecretCode_starts_with: String
  centerSecretCode_not_starts_with: String
  centerSecretCode_ends_with: String
  centerSecretCode_not_ends_with: String
  town: TownWhereInput
  centerNumber: Int
  centerNumber_not: Int
  centerNumber_in: [Int!]
  centerNumber_not_in: [Int!]
  centerNumber_lt: Int
  centerNumber_lte: Int
  centerNumber_gt: Int
  centerNumber_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  centerExamSessionExaminer_every: CenterExamSessionExaminerWhereInput
  centerExamSessionExaminer_some: CenterExamSessionExaminerWhereInput
  centerExamSessionExaminer_none: CenterExamSessionExaminerWhereInput
  centerExamSession_every: CenterExamSessionWhereInput
  centerExamSession_some: CenterExamSessionWhereInput
  centerExamSession_none: CenterExamSessionWhereInput
  AND: [CenterWhereInput!]
  OR: [CenterWhereInput!]
  NOT: [CenterWhereInput!]
}

input CenterWhereUniqueInput {
  id: ID
  centerCode: String
  centerSecretCode: String
  centerNumber: Int
}

scalar DateTime

type Division {
  id: ID!
  divName: String!
  divCode: String!
  region: Region!
  subDivision(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubDivision!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DivisionConnection {
  pageInfo: PageInfo!
  edges: [DivisionEdge]!
  aggregate: AggregateDivision!
}

input DivisionCreateInput {
  divName: String!
  divCode: String!
  region: RegionCreateOneWithoutDivisionInput!
  subDivision: SubDivisionCreateManyWithoutDivisionInput
}

input DivisionCreateManyWithoutRegionInput {
  create: [DivisionCreateWithoutRegionInput!]
  connect: [DivisionWhereUniqueInput!]
}

input DivisionCreateOneWithoutSubDivisionInput {
  create: DivisionCreateWithoutSubDivisionInput
  connect: DivisionWhereUniqueInput
}

input DivisionCreateWithoutRegionInput {
  divName: String!
  divCode: String!
  subDivision: SubDivisionCreateManyWithoutDivisionInput
}

input DivisionCreateWithoutSubDivisionInput {
  divName: String!
  divCode: String!
  region: RegionCreateOneWithoutDivisionInput!
}

type DivisionEdge {
  node: Division!
  cursor: String!
}

enum DivisionOrderByInput {
  id_ASC
  id_DESC
  divName_ASC
  divName_DESC
  divCode_ASC
  divCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type DivisionPreviousValues {
  id: ID!
  divName: String!
  divCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type DivisionSubscriptionPayload {
  mutation: MutationType!
  node: Division
  updatedFields: [String!]
  previousValues: DivisionPreviousValues
}

input DivisionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: DivisionWhereInput
  AND: [DivisionSubscriptionWhereInput!]
  OR: [DivisionSubscriptionWhereInput!]
  NOT: [DivisionSubscriptionWhereInput!]
}

input DivisionUpdateInput {
  divName: String
  divCode: String
  region: RegionUpdateOneRequiredWithoutDivisionInput
  subDivision: SubDivisionUpdateManyWithoutDivisionInput
}

input DivisionUpdateManyWithoutRegionInput {
  create: [DivisionCreateWithoutRegionInput!]
  delete: [DivisionWhereUniqueInput!]
  connect: [DivisionWhereUniqueInput!]
  disconnect: [DivisionWhereUniqueInput!]
  update: [DivisionUpdateWithWhereUniqueWithoutRegionInput!]
  upsert: [DivisionUpsertWithWhereUniqueWithoutRegionInput!]
}

input DivisionUpdateOneRequiredWithoutSubDivisionInput {
  create: DivisionCreateWithoutSubDivisionInput
  update: DivisionUpdateWithoutSubDivisionDataInput
  upsert: DivisionUpsertWithoutSubDivisionInput
  connect: DivisionWhereUniqueInput
}

input DivisionUpdateWithoutRegionDataInput {
  divName: String
  divCode: String
  subDivision: SubDivisionUpdateManyWithoutDivisionInput
}

input DivisionUpdateWithoutSubDivisionDataInput {
  divName: String
  divCode: String
  region: RegionUpdateOneRequiredWithoutDivisionInput
}

input DivisionUpdateWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput!
  data: DivisionUpdateWithoutRegionDataInput!
}

input DivisionUpsertWithoutSubDivisionInput {
  update: DivisionUpdateWithoutSubDivisionDataInput!
  create: DivisionCreateWithoutSubDivisionInput!
}

input DivisionUpsertWithWhereUniqueWithoutRegionInput {
  where: DivisionWhereUniqueInput!
  update: DivisionUpdateWithoutRegionDataInput!
  create: DivisionCreateWithoutRegionInput!
}

input DivisionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  divName: String
  divName_not: String
  divName_in: [String!]
  divName_not_in: [String!]
  divName_lt: String
  divName_lte: String
  divName_gt: String
  divName_gte: String
  divName_contains: String
  divName_not_contains: String
  divName_starts_with: String
  divName_not_starts_with: String
  divName_ends_with: String
  divName_not_ends_with: String
  divCode: String
  divCode_not: String
  divCode_in: [String!]
  divCode_not_in: [String!]
  divCode_lt: String
  divCode_lte: String
  divCode_gt: String
  divCode_gte: String
  divCode_contains: String
  divCode_not_contains: String
  divCode_starts_with: String
  divCode_not_starts_with: String
  divCode_ends_with: String
  divCode_not_ends_with: String
  region: RegionWhereInput
  subDivision_every: SubDivisionWhereInput
  subDivision_some: SubDivisionWhereInput
  subDivision_none: SubDivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [DivisionWhereInput!]
  OR: [DivisionWhereInput!]
  NOT: [DivisionWhereInput!]
}

input DivisionWhereUniqueInput {
  id: ID
  divCode: String
}

type EducationType {
  id: ID!
  subject(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject!]
  educationTypeName: String
  educationTypeCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  specialty(where: SpecialtyWhereInput, orderBy: SpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Specialty!]
}

type EducationTypeConnection {
  pageInfo: PageInfo!
  edges: [EducationTypeEdge]!
  aggregate: AggregateEducationType!
}

input EducationTypeCreateInput {
  subject: SubjectCreateManyWithoutEducTypeInput
  educationTypeName: String
  educationTypeCode: String!
  specialty: SpecialtyCreateManyWithoutEducationTypeInput
}

input EducationTypeCreateOneWithoutSpecialtyInput {
  create: EducationTypeCreateWithoutSpecialtyInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeCreateOneWithoutSubjectInput {
  create: EducationTypeCreateWithoutSubjectInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeCreateWithoutSpecialtyInput {
  subject: SubjectCreateManyWithoutEducTypeInput
  educationTypeName: String
  educationTypeCode: String!
}

input EducationTypeCreateWithoutSubjectInput {
  educationTypeName: String
  educationTypeCode: String!
  specialty: SpecialtyCreateManyWithoutEducationTypeInput
}

type EducationTypeEdge {
  node: EducationType!
  cursor: String!
}

enum EducationTypeOrderByInput {
  id_ASC
  id_DESC
  educationTypeName_ASC
  educationTypeName_DESC
  educationTypeCode_ASC
  educationTypeCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type EducationTypePreviousValues {
  id: ID!
  educationTypeName: String
  educationTypeCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type EducationTypeSubscriptionPayload {
  mutation: MutationType!
  node: EducationType
  updatedFields: [String!]
  previousValues: EducationTypePreviousValues
}

input EducationTypeSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: EducationTypeWhereInput
  AND: [EducationTypeSubscriptionWhereInput!]
  OR: [EducationTypeSubscriptionWhereInput!]
  NOT: [EducationTypeSubscriptionWhereInput!]
}

input EducationTypeUpdateInput {
  subject: SubjectUpdateManyWithoutEducTypeInput
  educationTypeName: String
  educationTypeCode: String
  specialty: SpecialtyUpdateManyWithoutEducationTypeInput
}

input EducationTypeUpdateOneRequiredWithoutSpecialtyInput {
  create: EducationTypeCreateWithoutSpecialtyInput
  update: EducationTypeUpdateWithoutSpecialtyDataInput
  upsert: EducationTypeUpsertWithoutSpecialtyInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeUpdateOneRequiredWithoutSubjectInput {
  create: EducationTypeCreateWithoutSubjectInput
  update: EducationTypeUpdateWithoutSubjectDataInput
  upsert: EducationTypeUpsertWithoutSubjectInput
  connect: EducationTypeWhereUniqueInput
}

input EducationTypeUpdateWithoutSpecialtyDataInput {
  subject: SubjectUpdateManyWithoutEducTypeInput
  educationTypeName: String
  educationTypeCode: String
}

input EducationTypeUpdateWithoutSubjectDataInput {
  educationTypeName: String
  educationTypeCode: String
  specialty: SpecialtyUpdateManyWithoutEducationTypeInput
}

input EducationTypeUpsertWithoutSpecialtyInput {
  update: EducationTypeUpdateWithoutSpecialtyDataInput!
  create: EducationTypeCreateWithoutSpecialtyInput!
}

input EducationTypeUpsertWithoutSubjectInput {
  update: EducationTypeUpdateWithoutSubjectDataInput!
  create: EducationTypeCreateWithoutSubjectInput!
}

input EducationTypeWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subject_every: SubjectWhereInput
  subject_some: SubjectWhereInput
  subject_none: SubjectWhereInput
  educationTypeName: String
  educationTypeName_not: String
  educationTypeName_in: [String!]
  educationTypeName_not_in: [String!]
  educationTypeName_lt: String
  educationTypeName_lte: String
  educationTypeName_gt: String
  educationTypeName_gte: String
  educationTypeName_contains: String
  educationTypeName_not_contains: String
  educationTypeName_starts_with: String
  educationTypeName_not_starts_with: String
  educationTypeName_ends_with: String
  educationTypeName_not_ends_with: String
  educationTypeCode: String
  educationTypeCode_not: String
  educationTypeCode_in: [String!]
  educationTypeCode_not_in: [String!]
  educationTypeCode_lt: String
  educationTypeCode_lte: String
  educationTypeCode_gt: String
  educationTypeCode_gte: String
  educationTypeCode_contains: String
  educationTypeCode_not_contains: String
  educationTypeCode_starts_with: String
  educationTypeCode_not_starts_with: String
  educationTypeCode_ends_with: String
  educationTypeCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  specialty_every: SpecialtyWhereInput
  specialty_some: SpecialtyWhereInput
  specialty_none: SpecialtyWhereInput
  AND: [EducationTypeWhereInput!]
  OR: [EducationTypeWhereInput!]
  NOT: [EducationTypeWhereInput!]
}

input EducationTypeWhereUniqueInput {
  id: ID
  educationTypeCode: String
}

type Exam {
  id: ID!
  examName: String!
  examSession(where: ExamSessionWhereInput, orderBy: ExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExamSession!]
  examCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExamConnection {
  pageInfo: PageInfo!
  edges: [ExamEdge]!
  aggregate: AggregateExam!
}

input ExamCreateInput {
  examName: String!
  examSession: ExamSessionCreateManyWithoutExamInput
  examCode: String!
}

input ExamCreateOneWithoutExamSessionInput {
  create: ExamCreateWithoutExamSessionInput
  connect: ExamWhereUniqueInput
}

input ExamCreateWithoutExamSessionInput {
  examName: String!
  examCode: String!
}

type ExamEdge {
  node: Exam!
  cursor: String!
}

type Examiner {
  id: ID!
  examiner1stName: String!
  examiner2ndName: String!
  examinerOtherNames: String!
  examinerCNI: String!
  examinerPhone: Int!
  examinerMatricule: String!
  examinerEmail: String!
  examinerImage: String!
  gender: String!
  examinerCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  user: User!
}

type ExaminerConnection {
  pageInfo: PageInfo!
  edges: [ExaminerEdge]!
  aggregate: AggregateExaminer!
}

input ExaminerCreateInput {
  examiner1stName: String!
  examiner2ndName: String!
  examinerOtherNames: String!
  examinerCNI: String!
  examinerPhone: Int!
  examinerMatricule: String!
  examinerEmail: String!
  examinerImage: String!
  gender: String!
  examinerCode: String!
  user: UserCreateOneInput!
}

input ExaminerCreateOneInput {
  create: ExaminerCreateInput
  connect: ExaminerWhereUniqueInput
}

type ExaminerEdge {
  node: Examiner!
  cursor: String!
}

enum ExaminerOrderByInput {
  id_ASC
  id_DESC
  examiner1stName_ASC
  examiner1stName_DESC
  examiner2ndName_ASC
  examiner2ndName_DESC
  examinerOtherNames_ASC
  examinerOtherNames_DESC
  examinerCNI_ASC
  examinerCNI_DESC
  examinerPhone_ASC
  examinerPhone_DESC
  examinerMatricule_ASC
  examinerMatricule_DESC
  examinerEmail_ASC
  examinerEmail_DESC
  examinerImage_ASC
  examinerImage_DESC
  gender_ASC
  gender_DESC
  examinerCode_ASC
  examinerCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExaminerPreviousValues {
  id: ID!
  examiner1stName: String!
  examiner2ndName: String!
  examinerOtherNames: String!
  examinerCNI: String!
  examinerPhone: Int!
  examinerMatricule: String!
  examinerEmail: String!
  examinerImage: String!
  gender: String!
  examinerCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExaminerSubscriptionPayload {
  mutation: MutationType!
  node: Examiner
  updatedFields: [String!]
  previousValues: ExaminerPreviousValues
}

input ExaminerSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExaminerWhereInput
  AND: [ExaminerSubscriptionWhereInput!]
  OR: [ExaminerSubscriptionWhereInput!]
  NOT: [ExaminerSubscriptionWhereInput!]
}

input ExaminerUpdateDataInput {
  examiner1stName: String
  examiner2ndName: String
  examinerOtherNames: String
  examinerCNI: String
  examinerPhone: Int
  examinerMatricule: String
  examinerEmail: String
  examinerImage: String
  gender: String
  examinerCode: String
  user: UserUpdateOneRequiredInput
}

input ExaminerUpdateInput {
  examiner1stName: String
  examiner2ndName: String
  examinerOtherNames: String
  examinerCNI: String
  examinerPhone: Int
  examinerMatricule: String
  examinerEmail: String
  examinerImage: String
  gender: String
  examinerCode: String
  user: UserUpdateOneRequiredInput
}

input ExaminerUpdateOneRequiredInput {
  create: ExaminerCreateInput
  update: ExaminerUpdateDataInput
  upsert: ExaminerUpsertNestedInput
  connect: ExaminerWhereUniqueInput
}

input ExaminerUpsertNestedInput {
  update: ExaminerUpdateDataInput!
  create: ExaminerCreateInput!
}

input ExaminerWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examiner1stName: String
  examiner1stName_not: String
  examiner1stName_in: [String!]
  examiner1stName_not_in: [String!]
  examiner1stName_lt: String
  examiner1stName_lte: String
  examiner1stName_gt: String
  examiner1stName_gte: String
  examiner1stName_contains: String
  examiner1stName_not_contains: String
  examiner1stName_starts_with: String
  examiner1stName_not_starts_with: String
  examiner1stName_ends_with: String
  examiner1stName_not_ends_with: String
  examiner2ndName: String
  examiner2ndName_not: String
  examiner2ndName_in: [String!]
  examiner2ndName_not_in: [String!]
  examiner2ndName_lt: String
  examiner2ndName_lte: String
  examiner2ndName_gt: String
  examiner2ndName_gte: String
  examiner2ndName_contains: String
  examiner2ndName_not_contains: String
  examiner2ndName_starts_with: String
  examiner2ndName_not_starts_with: String
  examiner2ndName_ends_with: String
  examiner2ndName_not_ends_with: String
  examinerOtherNames: String
  examinerOtherNames_not: String
  examinerOtherNames_in: [String!]
  examinerOtherNames_not_in: [String!]
  examinerOtherNames_lt: String
  examinerOtherNames_lte: String
  examinerOtherNames_gt: String
  examinerOtherNames_gte: String
  examinerOtherNames_contains: String
  examinerOtherNames_not_contains: String
  examinerOtherNames_starts_with: String
  examinerOtherNames_not_starts_with: String
  examinerOtherNames_ends_with: String
  examinerOtherNames_not_ends_with: String
  examinerCNI: String
  examinerCNI_not: String
  examinerCNI_in: [String!]
  examinerCNI_not_in: [String!]
  examinerCNI_lt: String
  examinerCNI_lte: String
  examinerCNI_gt: String
  examinerCNI_gte: String
  examinerCNI_contains: String
  examinerCNI_not_contains: String
  examinerCNI_starts_with: String
  examinerCNI_not_starts_with: String
  examinerCNI_ends_with: String
  examinerCNI_not_ends_with: String
  examinerPhone: Int
  examinerPhone_not: Int
  examinerPhone_in: [Int!]
  examinerPhone_not_in: [Int!]
  examinerPhone_lt: Int
  examinerPhone_lte: Int
  examinerPhone_gt: Int
  examinerPhone_gte: Int
  examinerMatricule: String
  examinerMatricule_not: String
  examinerMatricule_in: [String!]
  examinerMatricule_not_in: [String!]
  examinerMatricule_lt: String
  examinerMatricule_lte: String
  examinerMatricule_gt: String
  examinerMatricule_gte: String
  examinerMatricule_contains: String
  examinerMatricule_not_contains: String
  examinerMatricule_starts_with: String
  examinerMatricule_not_starts_with: String
  examinerMatricule_ends_with: String
  examinerMatricule_not_ends_with: String
  examinerEmail: String
  examinerEmail_not: String
  examinerEmail_in: [String!]
  examinerEmail_not_in: [String!]
  examinerEmail_lt: String
  examinerEmail_lte: String
  examinerEmail_gt: String
  examinerEmail_gte: String
  examinerEmail_contains: String
  examinerEmail_not_contains: String
  examinerEmail_starts_with: String
  examinerEmail_not_starts_with: String
  examinerEmail_ends_with: String
  examinerEmail_not_ends_with: String
  examinerImage: String
  examinerImage_not: String
  examinerImage_in: [String!]
  examinerImage_not_in: [String!]
  examinerImage_lt: String
  examinerImage_lte: String
  examinerImage_gt: String
  examinerImage_gte: String
  examinerImage_contains: String
  examinerImage_not_contains: String
  examinerImage_starts_with: String
  examinerImage_not_starts_with: String
  examinerImage_ends_with: String
  examinerImage_not_ends_with: String
  gender: String
  gender_not: String
  gender_in: [String!]
  gender_not_in: [String!]
  gender_lt: String
  gender_lte: String
  gender_gt: String
  gender_gte: String
  gender_contains: String
  gender_not_contains: String
  gender_starts_with: String
  gender_not_starts_with: String
  gender_ends_with: String
  gender_not_ends_with: String
  examinerCode: String
  examinerCode_not: String
  examinerCode_in: [String!]
  examinerCode_not_in: [String!]
  examinerCode_lt: String
  examinerCode_lte: String
  examinerCode_gt: String
  examinerCode_gte: String
  examinerCode_contains: String
  examinerCode_not_contains: String
  examinerCode_starts_with: String
  examinerCode_not_starts_with: String
  examinerCode_ends_with: String
  examinerCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  user: UserWhereInput
  AND: [ExaminerWhereInput!]
  OR: [ExaminerWhereInput!]
  NOT: [ExaminerWhereInput!]
}

input ExaminerWhereUniqueInput {
  id: ID
  examinerCode: String
}

enum ExamOrderByInput {
  id_ASC
  id_DESC
  examName_ASC
  examName_DESC
  examCode_ASC
  examCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExamPreviousValues {
  id: ID!
  examName: String!
  examCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExamSession {
  id: ID!
  exam: Exam!
  session: Session!
  centerExamSession(where: CenterExamSessionWhereInput, orderBy: CenterExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSession!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExamSessionConnection {
  pageInfo: PageInfo!
  edges: [ExamSessionEdge]!
  aggregate: AggregateExamSession!
}

input ExamSessionCreateInput {
  exam: ExamCreateOneWithoutExamSessionInput!
  session: SessionCreateOneWithoutExamSessionInput!
  centerExamSession: CenterExamSessionCreateManyWithoutExamSessionInput
}

input ExamSessionCreateManyWithoutExamInput {
  create: [ExamSessionCreateWithoutExamInput!]
  connect: [ExamSessionWhereUniqueInput!]
}

input ExamSessionCreateManyWithoutSessionInput {
  create: [ExamSessionCreateWithoutSessionInput!]
  connect: [ExamSessionWhereUniqueInput!]
}

input ExamSessionCreateOneWithoutCenterExamSessionInput {
  create: ExamSessionCreateWithoutCenterExamSessionInput
  connect: ExamSessionWhereUniqueInput
}

input ExamSessionCreateWithoutCenterExamSessionInput {
  exam: ExamCreateOneWithoutExamSessionInput!
  session: SessionCreateOneWithoutExamSessionInput!
}

input ExamSessionCreateWithoutExamInput {
  session: SessionCreateOneWithoutExamSessionInput!
  centerExamSession: CenterExamSessionCreateManyWithoutExamSessionInput
}

input ExamSessionCreateWithoutSessionInput {
  exam: ExamCreateOneWithoutExamSessionInput!
  centerExamSession: CenterExamSessionCreateManyWithoutExamSessionInput
}

type ExamSessionEdge {
  node: ExamSession!
  cursor: String!
}

enum ExamSessionOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ExamSessionPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ExamSessionSubscriptionPayload {
  mutation: MutationType!
  node: ExamSession
  updatedFields: [String!]
  previousValues: ExamSessionPreviousValues
}

input ExamSessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExamSessionWhereInput
  AND: [ExamSessionSubscriptionWhereInput!]
  OR: [ExamSessionSubscriptionWhereInput!]
  NOT: [ExamSessionSubscriptionWhereInput!]
}

input ExamSessionUpdateInput {
  exam: ExamUpdateOneRequiredWithoutExamSessionInput
  session: SessionUpdateOneRequiredWithoutExamSessionInput
  centerExamSession: CenterExamSessionUpdateManyWithoutExamSessionInput
}

input ExamSessionUpdateManyWithoutExamInput {
  create: [ExamSessionCreateWithoutExamInput!]
  delete: [ExamSessionWhereUniqueInput!]
  connect: [ExamSessionWhereUniqueInput!]
  disconnect: [ExamSessionWhereUniqueInput!]
  update: [ExamSessionUpdateWithWhereUniqueWithoutExamInput!]
  upsert: [ExamSessionUpsertWithWhereUniqueWithoutExamInput!]
}

input ExamSessionUpdateManyWithoutSessionInput {
  create: [ExamSessionCreateWithoutSessionInput!]
  delete: [ExamSessionWhereUniqueInput!]
  connect: [ExamSessionWhereUniqueInput!]
  disconnect: [ExamSessionWhereUniqueInput!]
  update: [ExamSessionUpdateWithWhereUniqueWithoutSessionInput!]
  upsert: [ExamSessionUpsertWithWhereUniqueWithoutSessionInput!]
}

input ExamSessionUpdateOneRequiredWithoutCenterExamSessionInput {
  create: ExamSessionCreateWithoutCenterExamSessionInput
  update: ExamSessionUpdateWithoutCenterExamSessionDataInput
  upsert: ExamSessionUpsertWithoutCenterExamSessionInput
  connect: ExamSessionWhereUniqueInput
}

input ExamSessionUpdateWithoutCenterExamSessionDataInput {
  exam: ExamUpdateOneRequiredWithoutExamSessionInput
  session: SessionUpdateOneRequiredWithoutExamSessionInput
}

input ExamSessionUpdateWithoutExamDataInput {
  session: SessionUpdateOneRequiredWithoutExamSessionInput
  centerExamSession: CenterExamSessionUpdateManyWithoutExamSessionInput
}

input ExamSessionUpdateWithoutSessionDataInput {
  exam: ExamUpdateOneRequiredWithoutExamSessionInput
  centerExamSession: CenterExamSessionUpdateManyWithoutExamSessionInput
}

input ExamSessionUpdateWithWhereUniqueWithoutExamInput {
  where: ExamSessionWhereUniqueInput!
  data: ExamSessionUpdateWithoutExamDataInput!
}

input ExamSessionUpdateWithWhereUniqueWithoutSessionInput {
  where: ExamSessionWhereUniqueInput!
  data: ExamSessionUpdateWithoutSessionDataInput!
}

input ExamSessionUpsertWithoutCenterExamSessionInput {
  update: ExamSessionUpdateWithoutCenterExamSessionDataInput!
  create: ExamSessionCreateWithoutCenterExamSessionInput!
}

input ExamSessionUpsertWithWhereUniqueWithoutExamInput {
  where: ExamSessionWhereUniqueInput!
  update: ExamSessionUpdateWithoutExamDataInput!
  create: ExamSessionCreateWithoutExamInput!
}

input ExamSessionUpsertWithWhereUniqueWithoutSessionInput {
  where: ExamSessionWhereUniqueInput!
  update: ExamSessionUpdateWithoutSessionDataInput!
  create: ExamSessionCreateWithoutSessionInput!
}

input ExamSessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  exam: ExamWhereInput
  session: SessionWhereInput
  centerExamSession_every: CenterExamSessionWhereInput
  centerExamSession_some: CenterExamSessionWhereInput
  centerExamSession_none: CenterExamSessionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExamSessionWhereInput!]
  OR: [ExamSessionWhereInput!]
  NOT: [ExamSessionWhereInput!]
}

input ExamSessionWhereUniqueInput {
  id: ID
}

type ExamSubscriptionPayload {
  mutation: MutationType!
  node: Exam
  updatedFields: [String!]
  previousValues: ExamPreviousValues
}

input ExamSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ExamWhereInput
  AND: [ExamSubscriptionWhereInput!]
  OR: [ExamSubscriptionWhereInput!]
  NOT: [ExamSubscriptionWhereInput!]
}

input ExamUpdateInput {
  examName: String
  examSession: ExamSessionUpdateManyWithoutExamInput
  examCode: String
}

input ExamUpdateOneRequiredWithoutExamSessionInput {
  create: ExamCreateWithoutExamSessionInput
  update: ExamUpdateWithoutExamSessionDataInput
  upsert: ExamUpsertWithoutExamSessionInput
  connect: ExamWhereUniqueInput
}

input ExamUpdateWithoutExamSessionDataInput {
  examName: String
  examCode: String
}

input ExamUpsertWithoutExamSessionInput {
  update: ExamUpdateWithoutExamSessionDataInput!
  create: ExamCreateWithoutExamSessionInput!
}

input ExamWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examName: String
  examName_not: String
  examName_in: [String!]
  examName_not_in: [String!]
  examName_lt: String
  examName_lte: String
  examName_gt: String
  examName_gte: String
  examName_contains: String
  examName_not_contains: String
  examName_starts_with: String
  examName_not_starts_with: String
  examName_ends_with: String
  examName_not_ends_with: String
  examSession_every: ExamSessionWhereInput
  examSession_some: ExamSessionWhereInput
  examSession_none: ExamSessionWhereInput
  examCode: String
  examCode_not: String
  examCode_in: [String!]
  examCode_not_in: [String!]
  examCode_lt: String
  examCode_lte: String
  examCode_gt: String
  examCode_gte: String
  examCode_contains: String
  examCode_not_contains: String
  examCode_starts_with: String
  examCode_not_starts_with: String
  examCode_ends_with: String
  examCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ExamWhereInput!]
  OR: [ExamWhereInput!]
  NOT: [ExamWhereInput!]
}

input ExamWhereUniqueInput {
  id: ID
  examCode: String
}

scalar Long

type Mutation {
  createCandidate(data: CandidateCreateInput!): Candidate!
  updateCandidate(data: CandidateUpdateInput!, where: CandidateWhereUniqueInput!): Candidate
  updateManyCandidates(data: CandidateUpdateInput!, where: CandidateWhereInput): BatchPayload!
  upsertCandidate(where: CandidateWhereUniqueInput!, create: CandidateCreateInput!, update: CandidateUpdateInput!): Candidate!
  deleteCandidate(where: CandidateWhereUniqueInput!): Candidate
  deleteManyCandidates(where: CandidateWhereInput): BatchPayload!
  createCenter(data: CenterCreateInput!): Center!
  updateCenter(data: CenterUpdateInput!, where: CenterWhereUniqueInput!): Center
  updateManyCenters(data: CenterUpdateInput!, where: CenterWhereInput): BatchPayload!
  upsertCenter(where: CenterWhereUniqueInput!, create: CenterCreateInput!, update: CenterUpdateInput!): Center!
  deleteCenter(where: CenterWhereUniqueInput!): Center
  deleteManyCenters(where: CenterWhereInput): BatchPayload!
  createCenterExamSession(data: CenterExamSessionCreateInput!): CenterExamSession!
  updateCenterExamSession(data: CenterExamSessionUpdateInput!, where: CenterExamSessionWhereUniqueInput!): CenterExamSession
  updateManyCenterExamSessions(data: CenterExamSessionUpdateInput!, where: CenterExamSessionWhereInput): BatchPayload!
  upsertCenterExamSession(where: CenterExamSessionWhereUniqueInput!, create: CenterExamSessionCreateInput!, update: CenterExamSessionUpdateInput!): CenterExamSession!
  deleteCenterExamSession(where: CenterExamSessionWhereUniqueInput!): CenterExamSession
  deleteManyCenterExamSessions(where: CenterExamSessionWhereInput): BatchPayload!
  createCenterExamSessionExaminer(data: CenterExamSessionExaminerCreateInput!): CenterExamSessionExaminer!
  updateCenterExamSessionExaminer(data: CenterExamSessionExaminerUpdateInput!, where: CenterExamSessionExaminerWhereUniqueInput!): CenterExamSessionExaminer
  updateManyCenterExamSessionExaminers(data: CenterExamSessionExaminerUpdateInput!, where: CenterExamSessionExaminerWhereInput): BatchPayload!
  upsertCenterExamSessionExaminer(where: CenterExamSessionExaminerWhereUniqueInput!, create: CenterExamSessionExaminerCreateInput!, update: CenterExamSessionExaminerUpdateInput!): CenterExamSessionExaminer!
  deleteCenterExamSessionExaminer(where: CenterExamSessionExaminerWhereUniqueInput!): CenterExamSessionExaminer
  deleteManyCenterExamSessionExaminers(where: CenterExamSessionExaminerWhereInput): BatchPayload!
  createCenterExamSessionSpecialty(data: CenterExamSessionSpecialtyCreateInput!): CenterExamSessionSpecialty!
  updateCenterExamSessionSpecialty(data: CenterExamSessionSpecialtyUpdateInput!, where: CenterExamSessionSpecialtyWhereUniqueInput!): CenterExamSessionSpecialty
  updateManyCenterExamSessionSpecialties(data: CenterExamSessionSpecialtyUpdateInput!, where: CenterExamSessionSpecialtyWhereInput): BatchPayload!
  upsertCenterExamSessionSpecialty(where: CenterExamSessionSpecialtyWhereUniqueInput!, create: CenterExamSessionSpecialtyCreateInput!, update: CenterExamSessionSpecialtyUpdateInput!): CenterExamSessionSpecialty!
  deleteCenterExamSessionSpecialty(where: CenterExamSessionSpecialtyWhereUniqueInput!): CenterExamSessionSpecialty
  deleteManyCenterExamSessionSpecialties(where: CenterExamSessionSpecialtyWhereInput): BatchPayload!
  createDivision(data: DivisionCreateInput!): Division!
  updateDivision(data: DivisionUpdateInput!, where: DivisionWhereUniqueInput!): Division
  updateManyDivisions(data: DivisionUpdateInput!, where: DivisionWhereInput): BatchPayload!
  upsertDivision(where: DivisionWhereUniqueInput!, create: DivisionCreateInput!, update: DivisionUpdateInput!): Division!
  deleteDivision(where: DivisionWhereUniqueInput!): Division
  deleteManyDivisions(where: DivisionWhereInput): BatchPayload!
  createEducationType(data: EducationTypeCreateInput!): EducationType!
  updateEducationType(data: EducationTypeUpdateInput!, where: EducationTypeWhereUniqueInput!): EducationType
  updateManyEducationTypes(data: EducationTypeUpdateInput!, where: EducationTypeWhereInput): BatchPayload!
  upsertEducationType(where: EducationTypeWhereUniqueInput!, create: EducationTypeCreateInput!, update: EducationTypeUpdateInput!): EducationType!
  deleteEducationType(where: EducationTypeWhereUniqueInput!): EducationType
  deleteManyEducationTypes(where: EducationTypeWhereInput): BatchPayload!
  createExam(data: ExamCreateInput!): Exam!
  updateExam(data: ExamUpdateInput!, where: ExamWhereUniqueInput!): Exam
  updateManyExams(data: ExamUpdateInput!, where: ExamWhereInput): BatchPayload!
  upsertExam(where: ExamWhereUniqueInput!, create: ExamCreateInput!, update: ExamUpdateInput!): Exam!
  deleteExam(where: ExamWhereUniqueInput!): Exam
  deleteManyExams(where: ExamWhereInput): BatchPayload!
  createExamSession(data: ExamSessionCreateInput!): ExamSession!
  updateExamSession(data: ExamSessionUpdateInput!, where: ExamSessionWhereUniqueInput!): ExamSession
  updateManyExamSessions(data: ExamSessionUpdateInput!, where: ExamSessionWhereInput): BatchPayload!
  upsertExamSession(where: ExamSessionWhereUniqueInput!, create: ExamSessionCreateInput!, update: ExamSessionUpdateInput!): ExamSession!
  deleteExamSession(where: ExamSessionWhereUniqueInput!): ExamSession
  deleteManyExamSessions(where: ExamSessionWhereInput): BatchPayload!
  createExaminer(data: ExaminerCreateInput!): Examiner!
  updateExaminer(data: ExaminerUpdateInput!, where: ExaminerWhereUniqueInput!): Examiner
  updateManyExaminers(data: ExaminerUpdateInput!, where: ExaminerWhereInput): BatchPayload!
  upsertExaminer(where: ExaminerWhereUniqueInput!, create: ExaminerCreateInput!, update: ExaminerUpdateInput!): Examiner!
  deleteExaminer(where: ExaminerWhereUniqueInput!): Examiner
  deleteManyExaminers(where: ExaminerWhereInput): BatchPayload!
  createPhase(data: PhaseCreateInput!): Phase!
  updatePhase(data: PhaseUpdateInput!, where: PhaseWhereUniqueInput!): Phase
  updateManyPhases(data: PhaseUpdateInput!, where: PhaseWhereInput): BatchPayload!
  upsertPhase(where: PhaseWhereUniqueInput!, create: PhaseCreateInput!, update: PhaseUpdateInput!): Phase!
  deletePhase(where: PhaseWhereUniqueInput!): Phase
  deleteManyPhases(where: PhaseWhereInput): BatchPayload!
  createPhaseRank(data: PhaseRankCreateInput!): PhaseRank!
  updatePhaseRank(data: PhaseRankUpdateInput!, where: PhaseRankWhereUniqueInput!): PhaseRank
  updateManyPhaseRanks(data: PhaseRankUpdateInput!, where: PhaseRankWhereInput): BatchPayload!
  upsertPhaseRank(where: PhaseRankWhereUniqueInput!, create: PhaseRankCreateInput!, update: PhaseRankUpdateInput!): PhaseRank!
  deletePhaseRank(where: PhaseRankWhereUniqueInput!): PhaseRank
  deleteManyPhaseRanks(where: PhaseRankWhereInput): BatchPayload!
  createRank(data: RankCreateInput!): Rank!
  updateRank(data: RankUpdateInput!, where: RankWhereUniqueInput!): Rank
  updateManyRanks(data: RankUpdateInput!, where: RankWhereInput): BatchPayload!
  upsertRank(where: RankWhereUniqueInput!, create: RankCreateInput!, update: RankUpdateInput!): Rank!
  deleteRank(where: RankWhereUniqueInput!): Rank
  deleteManyRanks(where: RankWhereInput): BatchPayload!
  createRegion(data: RegionCreateInput!): Region!
  updateRegion(data: RegionUpdateInput!, where: RegionWhereUniqueInput!): Region
  updateManyRegions(data: RegionUpdateInput!, where: RegionWhereInput): BatchPayload!
  upsertRegion(where: RegionWhereUniqueInput!, create: RegionCreateInput!, update: RegionUpdateInput!): Region!
  deleteRegion(where: RegionWhereUniqueInput!): Region
  deleteManyRegions(where: RegionWhereInput): BatchPayload!
  createRegisterOptionalSubject(data: RegisterOptionalSubjectCreateInput!): RegisterOptionalSubject!
  updateRegisterOptionalSubject(data: RegisterOptionalSubjectUpdateInput!, where: RegisterOptionalSubjectWhereUniqueInput!): RegisterOptionalSubject
  updateManyRegisterOptionalSubjects(data: RegisterOptionalSubjectUpdateInput!, where: RegisterOptionalSubjectWhereInput): BatchPayload!
  upsertRegisterOptionalSubject(where: RegisterOptionalSubjectWhereUniqueInput!, create: RegisterOptionalSubjectCreateInput!, update: RegisterOptionalSubjectUpdateInput!): RegisterOptionalSubject!
  deleteRegisterOptionalSubject(where: RegisterOptionalSubjectWhereUniqueInput!): RegisterOptionalSubject
  deleteManyRegisterOptionalSubjects(where: RegisterOptionalSubjectWhereInput): BatchPayload!
  createRegistration(data: RegistrationCreateInput!): Registration!
  updateRegistration(data: RegistrationUpdateInput!, where: RegistrationWhereUniqueInput!): Registration
  updateManyRegistrations(data: RegistrationUpdateInput!, where: RegistrationWhereInput): BatchPayload!
  upsertRegistration(where: RegistrationWhereUniqueInput!, create: RegistrationCreateInput!, update: RegistrationUpdateInput!): Registration!
  deleteRegistration(where: RegistrationWhereUniqueInput!): Registration
  deleteManyRegistrations(where: RegistrationWhereInput): BatchPayload!
  createReport(data: ReportCreateInput!): Report!
  updateReport(data: ReportUpdateInput!, where: ReportWhereUniqueInput!): Report
  updateManyReports(data: ReportUpdateInput!, where: ReportWhereInput): BatchPayload!
  upsertReport(where: ReportWhereUniqueInput!, create: ReportCreateInput!, update: ReportUpdateInput!): Report!
  deleteReport(where: ReportWhereUniqueInput!): Report
  deleteManyReports(where: ReportWhereInput): BatchPayload!
  createScore(data: ScoreCreateInput!): Score!
  updateScore(data: ScoreUpdateInput!, where: ScoreWhereUniqueInput!): Score
  updateManyScores(data: ScoreUpdateInput!, where: ScoreWhereInput): BatchPayload!
  upsertScore(where: ScoreWhereUniqueInput!, create: ScoreCreateInput!, update: ScoreUpdateInput!): Score!
  deleteScore(where: ScoreWhereUniqueInput!): Score
  deleteManyScores(where: ScoreWhereInput): BatchPayload!
  createSession(data: SessionCreateInput!): Session!
  updateSession(data: SessionUpdateInput!, where: SessionWhereUniqueInput!): Session
  updateManySessions(data: SessionUpdateInput!, where: SessionWhereInput): BatchPayload!
  upsertSession(where: SessionWhereUniqueInput!, create: SessionCreateInput!, update: SessionUpdateInput!): Session!
  deleteSession(where: SessionWhereUniqueInput!): Session
  deleteManySessions(where: SessionWhereInput): BatchPayload!
  createSpecialty(data: SpecialtyCreateInput!): Specialty!
  updateSpecialty(data: SpecialtyUpdateInput!, where: SpecialtyWhereUniqueInput!): Specialty
  updateManySpecialties(data: SpecialtyUpdateInput!, where: SpecialtyWhereInput): BatchPayload!
  upsertSpecialty(where: SpecialtyWhereUniqueInput!, create: SpecialtyCreateInput!, update: SpecialtyUpdateInput!): Specialty!
  deleteSpecialty(where: SpecialtyWhereUniqueInput!): Specialty
  deleteManySpecialties(where: SpecialtyWhereInput): BatchPayload!
  createSubDivision(data: SubDivisionCreateInput!): SubDivision!
  updateSubDivision(data: SubDivisionUpdateInput!, where: SubDivisionWhereUniqueInput!): SubDivision
  updateManySubDivisions(data: SubDivisionUpdateInput!, where: SubDivisionWhereInput): BatchPayload!
  upsertSubDivision(where: SubDivisionWhereUniqueInput!, create: SubDivisionCreateInput!, update: SubDivisionUpdateInput!): SubDivision!
  deleteSubDivision(where: SubDivisionWhereUniqueInput!): SubDivision
  deleteManySubDivisions(where: SubDivisionWhereInput): BatchPayload!
  createSubject(data: SubjectCreateInput!): Subject!
  updateSubject(data: SubjectUpdateInput!, where: SubjectWhereUniqueInput!): Subject
  updateManySubjects(data: SubjectUpdateInput!, where: SubjectWhereInput): BatchPayload!
  upsertSubject(where: SubjectWhereUniqueInput!, create: SubjectCreateInput!, update: SubjectUpdateInput!): Subject!
  deleteSubject(where: SubjectWhereUniqueInput!): Subject
  deleteManySubjects(where: SubjectWhereInput): BatchPayload!
  createSubjectSpecialty(data: SubjectSpecialtyCreateInput!): SubjectSpecialty!
  updateSubjectSpecialty(data: SubjectSpecialtyUpdateInput!, where: SubjectSpecialtyWhereUniqueInput!): SubjectSpecialty
  updateManySubjectSpecialties(data: SubjectSpecialtyUpdateInput!, where: SubjectSpecialtyWhereInput): BatchPayload!
  upsertSubjectSpecialty(where: SubjectSpecialtyWhereUniqueInput!, create: SubjectSpecialtyCreateInput!, update: SubjectSpecialtyUpdateInput!): SubjectSpecialty!
  deleteSubjectSpecialty(where: SubjectSpecialtyWhereUniqueInput!): SubjectSpecialty
  deleteManySubjectSpecialties(where: SubjectSpecialtyWhereInput): BatchPayload!
  createTown(data: TownCreateInput!): Town!
  updateTown(data: TownUpdateInput!, where: TownWhereUniqueInput!): Town
  updateManyTowns(data: TownUpdateInput!, where: TownWhereInput): BatchPayload!
  upsertTown(where: TownWhereUniqueInput!, create: TownCreateInput!, update: TownUpdateInput!): Town!
  deleteTown(where: TownWhereUniqueInput!): Town
  deleteManyTowns(where: TownWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

enum Permissions {
  ADMIN
  USER
  ENTER_MARKS
  CHEF_SEC
  CENTER_ADMIN
  EXAMINER
  EXAMINER_ADMIN
  PERMISSION_UPDATE
}

type Phase {
  id: ID!
  phaseName: String!
  phaseCode: String!
  phaseRank(where: PhaseRankWhereInput, orderBy: PhaseRankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhaseRank!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhaseConnection {
  pageInfo: PageInfo!
  edges: [PhaseEdge]!
  aggregate: AggregatePhase!
}

input PhaseCreateInput {
  phaseName: String!
  phaseCode: String!
  phaseRank: PhaseRankCreateManyWithoutPhaseInput
}

input PhaseCreateOneWithoutPhaseRankInput {
  create: PhaseCreateWithoutPhaseRankInput
  connect: PhaseWhereUniqueInput
}

input PhaseCreateWithoutPhaseRankInput {
  phaseName: String!
  phaseCode: String!
}

type PhaseEdge {
  node: Phase!
  cursor: String!
}

enum PhaseOrderByInput {
  id_ASC
  id_DESC
  phaseName_ASC
  phaseName_DESC
  phaseCode_ASC
  phaseCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhasePreviousValues {
  id: ID!
  phaseName: String!
  phaseCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhaseRank {
  id: ID!
  phase: Phase!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhaseRankConnection {
  pageInfo: PageInfo!
  edges: [PhaseRankEdge]!
  aggregate: AggregatePhaseRank!
}

input PhaseRankCreateInput {
  phase: PhaseCreateOneWithoutPhaseRankInput!
  rankName: String!
  rankCode: String!
}

input PhaseRankCreateManyWithoutPhaseInput {
  create: [PhaseRankCreateWithoutPhaseInput!]
  connect: [PhaseRankWhereUniqueInput!]
}

input PhaseRankCreateOneInput {
  create: PhaseRankCreateInput
  connect: PhaseRankWhereUniqueInput
}

input PhaseRankCreateWithoutPhaseInput {
  rankName: String!
  rankCode: String!
}

type PhaseRankEdge {
  node: PhaseRank!
  cursor: String!
}

enum PhaseRankOrderByInput {
  id_ASC
  id_DESC
  rankName_ASC
  rankName_DESC
  rankCode_ASC
  rankCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type PhaseRankPreviousValues {
  id: ID!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type PhaseRankSubscriptionPayload {
  mutation: MutationType!
  node: PhaseRank
  updatedFields: [String!]
  previousValues: PhaseRankPreviousValues
}

input PhaseRankSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhaseRankWhereInput
  AND: [PhaseRankSubscriptionWhereInput!]
  OR: [PhaseRankSubscriptionWhereInput!]
  NOT: [PhaseRankSubscriptionWhereInput!]
}

input PhaseRankUpdateDataInput {
  phase: PhaseUpdateOneRequiredWithoutPhaseRankInput
  rankName: String
  rankCode: String
}

input PhaseRankUpdateInput {
  phase: PhaseUpdateOneRequiredWithoutPhaseRankInput
  rankName: String
  rankCode: String
}

input PhaseRankUpdateManyWithoutPhaseInput {
  create: [PhaseRankCreateWithoutPhaseInput!]
  delete: [PhaseRankWhereUniqueInput!]
  connect: [PhaseRankWhereUniqueInput!]
  disconnect: [PhaseRankWhereUniqueInput!]
  update: [PhaseRankUpdateWithWhereUniqueWithoutPhaseInput!]
  upsert: [PhaseRankUpsertWithWhereUniqueWithoutPhaseInput!]
}

input PhaseRankUpdateOneRequiredInput {
  create: PhaseRankCreateInput
  update: PhaseRankUpdateDataInput
  upsert: PhaseRankUpsertNestedInput
  connect: PhaseRankWhereUniqueInput
}

input PhaseRankUpdateWithoutPhaseDataInput {
  rankName: String
  rankCode: String
}

input PhaseRankUpdateWithWhereUniqueWithoutPhaseInput {
  where: PhaseRankWhereUniqueInput!
  data: PhaseRankUpdateWithoutPhaseDataInput!
}

input PhaseRankUpsertNestedInput {
  update: PhaseRankUpdateDataInput!
  create: PhaseRankCreateInput!
}

input PhaseRankUpsertWithWhereUniqueWithoutPhaseInput {
  where: PhaseRankWhereUniqueInput!
  update: PhaseRankUpdateWithoutPhaseDataInput!
  create: PhaseRankCreateWithoutPhaseInput!
}

input PhaseRankWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phase: PhaseWhereInput
  rankName: String
  rankName_not: String
  rankName_in: [String!]
  rankName_not_in: [String!]
  rankName_lt: String
  rankName_lte: String
  rankName_gt: String
  rankName_gte: String
  rankName_contains: String
  rankName_not_contains: String
  rankName_starts_with: String
  rankName_not_starts_with: String
  rankName_ends_with: String
  rankName_not_ends_with: String
  rankCode: String
  rankCode_not: String
  rankCode_in: [String!]
  rankCode_not_in: [String!]
  rankCode_lt: String
  rankCode_lte: String
  rankCode_gt: String
  rankCode_gte: String
  rankCode_contains: String
  rankCode_not_contains: String
  rankCode_starts_with: String
  rankCode_not_starts_with: String
  rankCode_ends_with: String
  rankCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhaseRankWhereInput!]
  OR: [PhaseRankWhereInput!]
  NOT: [PhaseRankWhereInput!]
}

input PhaseRankWhereUniqueInput {
  id: ID
}

type PhaseSubscriptionPayload {
  mutation: MutationType!
  node: Phase
  updatedFields: [String!]
  previousValues: PhasePreviousValues
}

input PhaseSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PhaseWhereInput
  AND: [PhaseSubscriptionWhereInput!]
  OR: [PhaseSubscriptionWhereInput!]
  NOT: [PhaseSubscriptionWhereInput!]
}

input PhaseUpdateInput {
  phaseName: String
  phaseCode: String
  phaseRank: PhaseRankUpdateManyWithoutPhaseInput
}

input PhaseUpdateOneRequiredWithoutPhaseRankInput {
  create: PhaseCreateWithoutPhaseRankInput
  update: PhaseUpdateWithoutPhaseRankDataInput
  upsert: PhaseUpsertWithoutPhaseRankInput
  connect: PhaseWhereUniqueInput
}

input PhaseUpdateWithoutPhaseRankDataInput {
  phaseName: String
  phaseCode: String
}

input PhaseUpsertWithoutPhaseRankInput {
  update: PhaseUpdateWithoutPhaseRankDataInput!
  create: PhaseCreateWithoutPhaseRankInput!
}

input PhaseWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  phaseName: String
  phaseName_not: String
  phaseName_in: [String!]
  phaseName_not_in: [String!]
  phaseName_lt: String
  phaseName_lte: String
  phaseName_gt: String
  phaseName_gte: String
  phaseName_contains: String
  phaseName_not_contains: String
  phaseName_starts_with: String
  phaseName_not_starts_with: String
  phaseName_ends_with: String
  phaseName_not_ends_with: String
  phaseCode: String
  phaseCode_not: String
  phaseCode_in: [String!]
  phaseCode_not_in: [String!]
  phaseCode_lt: String
  phaseCode_lte: String
  phaseCode_gt: String
  phaseCode_gte: String
  phaseCode_contains: String
  phaseCode_not_contains: String
  phaseCode_starts_with: String
  phaseCode_not_starts_with: String
  phaseCode_ends_with: String
  phaseCode_not_ends_with: String
  phaseRank_every: PhaseRankWhereInput
  phaseRank_some: PhaseRankWhereInput
  phaseRank_none: PhaseRankWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [PhaseWhereInput!]
  OR: [PhaseWhereInput!]
  NOT: [PhaseWhereInput!]
}

input PhaseWhereUniqueInput {
  id: ID
}

type Query {
  candidate(where: CandidateWhereUniqueInput!): Candidate
  candidates(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Candidate]!
  candidatesConnection(where: CandidateWhereInput, orderBy: CandidateOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CandidateConnection!
  center(where: CenterWhereUniqueInput!): Center
  centers(where: CenterWhereInput, orderBy: CenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Center]!
  centersConnection(where: CenterWhereInput, orderBy: CenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CenterConnection!
  centerExamSession(where: CenterExamSessionWhereUniqueInput!): CenterExamSession
  centerExamSessions(where: CenterExamSessionWhereInput, orderBy: CenterExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSession]!
  centerExamSessionsConnection(where: CenterExamSessionWhereInput, orderBy: CenterExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CenterExamSessionConnection!
  centerExamSessionExaminer(where: CenterExamSessionExaminerWhereUniqueInput!): CenterExamSessionExaminer
  centerExamSessionExaminers(where: CenterExamSessionExaminerWhereInput, orderBy: CenterExamSessionExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionExaminer]!
  centerExamSessionExaminersConnection(where: CenterExamSessionExaminerWhereInput, orderBy: CenterExamSessionExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CenterExamSessionExaminerConnection!
  centerExamSessionSpecialty(where: CenterExamSessionSpecialtyWhereUniqueInput!): CenterExamSessionSpecialty
  centerExamSessionSpecialties(where: CenterExamSessionSpecialtyWhereInput, orderBy: CenterExamSessionSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionSpecialty]!
  centerExamSessionSpecialtiesConnection(where: CenterExamSessionSpecialtyWhereInput, orderBy: CenterExamSessionSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): CenterExamSessionSpecialtyConnection!
  division(where: DivisionWhereUniqueInput!): Division
  divisions(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Division]!
  divisionsConnection(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): DivisionConnection!
  educationType(where: EducationTypeWhereUniqueInput!): EducationType
  educationTypes(where: EducationTypeWhereInput, orderBy: EducationTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [EducationType]!
  educationTypesConnection(where: EducationTypeWhereInput, orderBy: EducationTypeOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): EducationTypeConnection!
  exam(where: ExamWhereUniqueInput!): Exam
  exams(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Exam]!
  examsConnection(where: ExamWhereInput, orderBy: ExamOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExamConnection!
  examSession(where: ExamSessionWhereUniqueInput!): ExamSession
  examSessions(where: ExamSessionWhereInput, orderBy: ExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExamSession]!
  examSessionsConnection(where: ExamSessionWhereInput, orderBy: ExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExamSessionConnection!
  examiner(where: ExaminerWhereUniqueInput!): Examiner
  examiners(where: ExaminerWhereInput, orderBy: ExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Examiner]!
  examinersConnection(where: ExaminerWhereInput, orderBy: ExaminerOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ExaminerConnection!
  phase(where: PhaseWhereUniqueInput!): Phase
  phases(where: PhaseWhereInput, orderBy: PhaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Phase]!
  phasesConnection(where: PhaseWhereInput, orderBy: PhaseOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhaseConnection!
  phaseRank(where: PhaseRankWhereUniqueInput!): PhaseRank
  phaseRanks(where: PhaseRankWhereInput, orderBy: PhaseRankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [PhaseRank]!
  phaseRanksConnection(where: PhaseRankWhereInput, orderBy: PhaseRankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PhaseRankConnection!
  rank(where: RankWhereUniqueInput!): Rank
  ranks(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Rank]!
  ranksConnection(where: RankWhereInput, orderBy: RankOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RankConnection!
  region(where: RegionWhereUniqueInput!): Region
  regions(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Region]!
  regionsConnection(where: RegionWhereInput, orderBy: RegionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegionConnection!
  registerOptionalSubject(where: RegisterOptionalSubjectWhereUniqueInput!): RegisterOptionalSubject
  registerOptionalSubjects(where: RegisterOptionalSubjectWhereInput, orderBy: RegisterOptionalSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RegisterOptionalSubject]!
  registerOptionalSubjectsConnection(where: RegisterOptionalSubjectWhereInput, orderBy: RegisterOptionalSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegisterOptionalSubjectConnection!
  registration(where: RegistrationWhereUniqueInput!): Registration
  registrations(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Registration]!
  registrationsConnection(where: RegistrationWhereInput, orderBy: RegistrationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): RegistrationConnection!
  report(where: ReportWhereUniqueInput!): Report
  reports(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Report]!
  reportsConnection(where: ReportWhereInput, orderBy: ReportOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ReportConnection!
  score(where: ScoreWhereUniqueInput!): Score
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score]!
  scoresConnection(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ScoreConnection!
  session(where: SessionWhereUniqueInput!): Session
  sessions(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Session]!
  sessionsConnection(where: SessionWhereInput, orderBy: SessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SessionConnection!
  specialty(where: SpecialtyWhereUniqueInput!): Specialty
  specialties(where: SpecialtyWhereInput, orderBy: SpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Specialty]!
  specialtiesConnection(where: SpecialtyWhereInput, orderBy: SpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SpecialtyConnection!
  subDivision(where: SubDivisionWhereUniqueInput!): SubDivision
  subDivisions(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubDivision]!
  subDivisionsConnection(where: SubDivisionWhereInput, orderBy: SubDivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubDivisionConnection!
  subject(where: SubjectWhereUniqueInput!): Subject
  subjects(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Subject]!
  subjectsConnection(where: SubjectWhereInput, orderBy: SubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectConnection!
  subjectSpecialty(where: SubjectSpecialtyWhereUniqueInput!): SubjectSpecialty
  subjectSpecialties(where: SubjectSpecialtyWhereInput, orderBy: SubjectSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubjectSpecialty]!
  subjectSpecialtiesConnection(where: SubjectSpecialtyWhereInput, orderBy: SubjectSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): SubjectSpecialtyConnection!
  town(where: TownWhereUniqueInput!): Town
  towns(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Town]!
  townsConnection(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): TownConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Rank {
  id: ID!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RankConnection {
  pageInfo: PageInfo!
  edges: [RankEdge]!
  aggregate: AggregateRank!
}

input RankCreateInput {
  rankName: String!
  rankCode: String!
}

type RankEdge {
  node: Rank!
  cursor: String!
}

enum RankOrderByInput {
  id_ASC
  id_DESC
  rankName_ASC
  rankName_DESC
  rankCode_ASC
  rankCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RankPreviousValues {
  id: ID!
  rankName: String!
  rankCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RankSubscriptionPayload {
  mutation: MutationType!
  node: Rank
  updatedFields: [String!]
  previousValues: RankPreviousValues
}

input RankSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RankWhereInput
  AND: [RankSubscriptionWhereInput!]
  OR: [RankSubscriptionWhereInput!]
  NOT: [RankSubscriptionWhereInput!]
}

input RankUpdateInput {
  rankName: String
  rankCode: String
}

input RankWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  rankName: String
  rankName_not: String
  rankName_in: [String!]
  rankName_not_in: [String!]
  rankName_lt: String
  rankName_lte: String
  rankName_gt: String
  rankName_gte: String
  rankName_contains: String
  rankName_not_contains: String
  rankName_starts_with: String
  rankName_not_starts_with: String
  rankName_ends_with: String
  rankName_not_ends_with: String
  rankCode: String
  rankCode_not: String
  rankCode_in: [String!]
  rankCode_not_in: [String!]
  rankCode_lt: String
  rankCode_lte: String
  rankCode_gt: String
  rankCode_gte: String
  rankCode_contains: String
  rankCode_not_contains: String
  rankCode_starts_with: String
  rankCode_not_starts_with: String
  rankCode_ends_with: String
  rankCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RankWhereInput!]
  OR: [RankWhereInput!]
  NOT: [RankWhereInput!]
}

input RankWhereUniqueInput {
  id: ID
}

type Region {
  id: ID!
  regName: String!
  regCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
  division(where: DivisionWhereInput, orderBy: DivisionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Division!]
}

type RegionConnection {
  pageInfo: PageInfo!
  edges: [RegionEdge]!
  aggregate: AggregateRegion!
}

input RegionCreateInput {
  regName: String!
  regCode: String!
  division: DivisionCreateManyWithoutRegionInput
}

input RegionCreateOneWithoutDivisionInput {
  create: RegionCreateWithoutDivisionInput
  connect: RegionWhereUniqueInput
}

input RegionCreateWithoutDivisionInput {
  regName: String!
  regCode: String!
}

type RegionEdge {
  node: Region!
  cursor: String!
}

enum RegionOrderByInput {
  id_ASC
  id_DESC
  regName_ASC
  regName_DESC
  regCode_ASC
  regCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegionPreviousValues {
  id: ID!
  regName: String!
  regCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegionSubscriptionPayload {
  mutation: MutationType!
  node: Region
  updatedFields: [String!]
  previousValues: RegionPreviousValues
}

input RegionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegionWhereInput
  AND: [RegionSubscriptionWhereInput!]
  OR: [RegionSubscriptionWhereInput!]
  NOT: [RegionSubscriptionWhereInput!]
}

input RegionUpdateInput {
  regName: String
  regCode: String
  division: DivisionUpdateManyWithoutRegionInput
}

input RegionUpdateOneRequiredWithoutDivisionInput {
  create: RegionCreateWithoutDivisionInput
  update: RegionUpdateWithoutDivisionDataInput
  upsert: RegionUpsertWithoutDivisionInput
  connect: RegionWhereUniqueInput
}

input RegionUpdateWithoutDivisionDataInput {
  regName: String
  regCode: String
}

input RegionUpsertWithoutDivisionInput {
  update: RegionUpdateWithoutDivisionDataInput!
  create: RegionCreateWithoutDivisionInput!
}

input RegionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  regName: String
  regName_not: String
  regName_in: [String!]
  regName_not_in: [String!]
  regName_lt: String
  regName_lte: String
  regName_gt: String
  regName_gte: String
  regName_contains: String
  regName_not_contains: String
  regName_starts_with: String
  regName_not_starts_with: String
  regName_ends_with: String
  regName_not_ends_with: String
  regCode: String
  regCode_not: String
  regCode_in: [String!]
  regCode_not_in: [String!]
  regCode_lt: String
  regCode_lte: String
  regCode_gt: String
  regCode_gte: String
  regCode_contains: String
  regCode_not_contains: String
  regCode_starts_with: String
  regCode_not_starts_with: String
  regCode_ends_with: String
  regCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  division_every: DivisionWhereInput
  division_some: DivisionWhereInput
  division_none: DivisionWhereInput
  AND: [RegionWhereInput!]
  OR: [RegionWhereInput!]
  NOT: [RegionWhereInput!]
}

input RegionWhereUniqueInput {
  id: ID
  regCode: String
}

type RegisterOptionalSubject {
  id: ID!
  registration: Registration!
  Subject: Subject!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegisterOptionalSubjectConnection {
  pageInfo: PageInfo!
  edges: [RegisterOptionalSubjectEdge]!
  aggregate: AggregateRegisterOptionalSubject!
}

input RegisterOptionalSubjectCreateInput {
  registration: RegistrationCreateOneWithoutOptionalSubjectsInput!
  Subject: SubjectCreateOneInput!
}

input RegisterOptionalSubjectCreateManyWithoutRegistrationInput {
  create: [RegisterOptionalSubjectCreateWithoutRegistrationInput!]
  connect: [RegisterOptionalSubjectWhereUniqueInput!]
}

input RegisterOptionalSubjectCreateWithoutRegistrationInput {
  Subject: SubjectCreateOneInput!
}

type RegisterOptionalSubjectEdge {
  node: RegisterOptionalSubject!
  cursor: String!
}

enum RegisterOptionalSubjectOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegisterOptionalSubjectPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegisterOptionalSubjectSubscriptionPayload {
  mutation: MutationType!
  node: RegisterOptionalSubject
  updatedFields: [String!]
  previousValues: RegisterOptionalSubjectPreviousValues
}

input RegisterOptionalSubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegisterOptionalSubjectWhereInput
  AND: [RegisterOptionalSubjectSubscriptionWhereInput!]
  OR: [RegisterOptionalSubjectSubscriptionWhereInput!]
  NOT: [RegisterOptionalSubjectSubscriptionWhereInput!]
}

input RegisterOptionalSubjectUpdateInput {
  registration: RegistrationUpdateOneRequiredWithoutOptionalSubjectsInput
  Subject: SubjectUpdateOneRequiredInput
}

input RegisterOptionalSubjectUpdateManyWithoutRegistrationInput {
  create: [RegisterOptionalSubjectCreateWithoutRegistrationInput!]
  delete: [RegisterOptionalSubjectWhereUniqueInput!]
  connect: [RegisterOptionalSubjectWhereUniqueInput!]
  disconnect: [RegisterOptionalSubjectWhereUniqueInput!]
  update: [RegisterOptionalSubjectUpdateWithWhereUniqueWithoutRegistrationInput!]
  upsert: [RegisterOptionalSubjectUpsertWithWhereUniqueWithoutRegistrationInput!]
}

input RegisterOptionalSubjectUpdateWithoutRegistrationDataInput {
  Subject: SubjectUpdateOneRequiredInput
}

input RegisterOptionalSubjectUpdateWithWhereUniqueWithoutRegistrationInput {
  where: RegisterOptionalSubjectWhereUniqueInput!
  data: RegisterOptionalSubjectUpdateWithoutRegistrationDataInput!
}

input RegisterOptionalSubjectUpsertWithWhereUniqueWithoutRegistrationInput {
  where: RegisterOptionalSubjectWhereUniqueInput!
  update: RegisterOptionalSubjectUpdateWithoutRegistrationDataInput!
  create: RegisterOptionalSubjectCreateWithoutRegistrationInput!
}

input RegisterOptionalSubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  registration: RegistrationWhereInput
  Subject: SubjectWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RegisterOptionalSubjectWhereInput!]
  OR: [RegisterOptionalSubjectWhereInput!]
  NOT: [RegisterOptionalSubjectWhereInput!]
}

input RegisterOptionalSubjectWhereUniqueInput {
  id: ID
}

type Registration {
  id: ID!
  candidate: Candidate!
  centerExamSessionSpecialty: CenterExamSessionSpecialty!
  centerExamSession: CenterExamSession!
  candExamSecretCode: String!
  candExamSession: String!
  scores(where: ScoreWhereInput, orderBy: ScoreOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Score!]
  aptitude: String!
  specialty: Specialty!
  optionalSubjects(where: RegisterOptionalSubjectWhereInput, orderBy: RegisterOptionalSubjectOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [RegisterOptionalSubject!]
  candRegistrationNumber: String!
  serial: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegistrationConnection {
  pageInfo: PageInfo!
  edges: [RegistrationEdge]!
  aggregate: AggregateRegistration!
}

input RegistrationCreateInput {
  candidate: CandidateCreateOneWithoutRegistrationInput!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput!
  centerExamSession: CenterExamSessionCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  scores: ScoreCreateManyWithoutRegistrationInput
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  optionalSubjects: RegisterOptionalSubjectCreateManyWithoutRegistrationInput
  candRegistrationNumber: String!
  serial: Int
}

input RegistrationCreateManyWithoutCandidateInput {
  create: [RegistrationCreateWithoutCandidateInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutCenterExamSessionInput {
  create: [RegistrationCreateWithoutCenterExamSessionInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateManyWithoutCenterExamSessionSpecialtyInput {
  create: [RegistrationCreateWithoutCenterExamSessionSpecialtyInput!]
  connect: [RegistrationWhereUniqueInput!]
}

input RegistrationCreateOneWithoutOptionalSubjectsInput {
  create: RegistrationCreateWithoutOptionalSubjectsInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationCreateOneWithoutScoresInput {
  create: RegistrationCreateWithoutScoresInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationCreateWithoutCandidateInput {
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput!
  centerExamSession: CenterExamSessionCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  scores: ScoreCreateManyWithoutRegistrationInput
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  optionalSubjects: RegisterOptionalSubjectCreateManyWithoutRegistrationInput
  candRegistrationNumber: String!
  serial: Int
}

input RegistrationCreateWithoutCenterExamSessionInput {
  candidate: CandidateCreateOneWithoutRegistrationInput!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  scores: ScoreCreateManyWithoutRegistrationInput
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  optionalSubjects: RegisterOptionalSubjectCreateManyWithoutRegistrationInput
  candRegistrationNumber: String!
  serial: Int
}

input RegistrationCreateWithoutCenterExamSessionSpecialtyInput {
  candidate: CandidateCreateOneWithoutRegistrationInput!
  centerExamSession: CenterExamSessionCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  scores: ScoreCreateManyWithoutRegistrationInput
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  optionalSubjects: RegisterOptionalSubjectCreateManyWithoutRegistrationInput
  candRegistrationNumber: String!
  serial: Int
}

input RegistrationCreateWithoutOptionalSubjectsInput {
  candidate: CandidateCreateOneWithoutRegistrationInput!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput!
  centerExamSession: CenterExamSessionCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  scores: ScoreCreateManyWithoutRegistrationInput
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  candRegistrationNumber: String!
  serial: Int
}

input RegistrationCreateWithoutScoresInput {
  candidate: CandidateCreateOneWithoutRegistrationInput!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateOneWithoutRegistrationInput!
  centerExamSession: CenterExamSessionCreateOneWithoutRegistrationInput!
  candExamSecretCode: String!
  candExamSession: String!
  aptitude: String!
  specialty: SpecialtyCreateOneInput!
  optionalSubjects: RegisterOptionalSubjectCreateManyWithoutRegistrationInput
  candRegistrationNumber: String!
  serial: Int
}

type RegistrationEdge {
  node: Registration!
  cursor: String!
}

enum RegistrationOrderByInput {
  id_ASC
  id_DESC
  candExamSecretCode_ASC
  candExamSecretCode_DESC
  candExamSession_ASC
  candExamSession_DESC
  aptitude_ASC
  aptitude_DESC
  candRegistrationNumber_ASC
  candRegistrationNumber_DESC
  serial_ASC
  serial_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type RegistrationPreviousValues {
  id: ID!
  candExamSecretCode: String!
  candExamSession: String!
  aptitude: String!
  candRegistrationNumber: String!
  serial: Int
  createdAt: DateTime!
  updatedAt: DateTime!
}

type RegistrationSubscriptionPayload {
  mutation: MutationType!
  node: Registration
  updatedFields: [String!]
  previousValues: RegistrationPreviousValues
}

input RegistrationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: RegistrationWhereInput
  AND: [RegistrationSubscriptionWhereInput!]
  OR: [RegistrationSubscriptionWhereInput!]
  NOT: [RegistrationSubscriptionWhereInput!]
}

input RegistrationUpdateInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  scores: ScoreUpdateManyWithoutRegistrationInput
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  optionalSubjects: RegisterOptionalSubjectUpdateManyWithoutRegistrationInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateManyWithoutCandidateInput {
  create: [RegistrationCreateWithoutCandidateInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCandidateInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCandidateInput!]
}

input RegistrationUpdateManyWithoutCenterExamSessionInput {
  create: [RegistrationCreateWithoutCenterExamSessionInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCenterExamSessionInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCenterExamSessionInput!]
}

input RegistrationUpdateManyWithoutCenterExamSessionSpecialtyInput {
  create: [RegistrationCreateWithoutCenterExamSessionSpecialtyInput!]
  delete: [RegistrationWhereUniqueInput!]
  connect: [RegistrationWhereUniqueInput!]
  disconnect: [RegistrationWhereUniqueInput!]
  update: [RegistrationUpdateWithWhereUniqueWithoutCenterExamSessionSpecialtyInput!]
  upsert: [RegistrationUpsertWithWhereUniqueWithoutCenterExamSessionSpecialtyInput!]
}

input RegistrationUpdateOneRequiredWithoutOptionalSubjectsInput {
  create: RegistrationCreateWithoutOptionalSubjectsInput
  update: RegistrationUpdateWithoutOptionalSubjectsDataInput
  upsert: RegistrationUpsertWithoutOptionalSubjectsInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationUpdateOneRequiredWithoutScoresInput {
  create: RegistrationCreateWithoutScoresInput
  update: RegistrationUpdateWithoutScoresDataInput
  upsert: RegistrationUpsertWithoutScoresInput
  connect: RegistrationWhereUniqueInput
}

input RegistrationUpdateWithoutCandidateDataInput {
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  scores: ScoreUpdateManyWithoutRegistrationInput
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  optionalSubjects: RegisterOptionalSubjectUpdateManyWithoutRegistrationInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateWithoutCenterExamSessionDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  scores: ScoreUpdateManyWithoutRegistrationInput
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  optionalSubjects: RegisterOptionalSubjectUpdateManyWithoutRegistrationInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateWithoutCenterExamSessionSpecialtyDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  scores: ScoreUpdateManyWithoutRegistrationInput
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  optionalSubjects: RegisterOptionalSubjectUpdateManyWithoutRegistrationInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateWithoutOptionalSubjectsDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  scores: ScoreUpdateManyWithoutRegistrationInput
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateWithoutScoresDataInput {
  candidate: CandidateUpdateOneRequiredWithoutRegistrationInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateOneRequiredWithoutRegistrationInput
  centerExamSession: CenterExamSessionUpdateOneRequiredWithoutRegistrationInput
  candExamSecretCode: String
  candExamSession: String
  aptitude: String
  specialty: SpecialtyUpdateOneRequiredInput
  optionalSubjects: RegisterOptionalSubjectUpdateManyWithoutRegistrationInput
  candRegistrationNumber: String
  serial: Int
}

input RegistrationUpdateWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutCandidateDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutCenterExamSessionInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutCenterExamSessionDataInput!
}

input RegistrationUpdateWithWhereUniqueWithoutCenterExamSessionSpecialtyInput {
  where: RegistrationWhereUniqueInput!
  data: RegistrationUpdateWithoutCenterExamSessionSpecialtyDataInput!
}

input RegistrationUpsertWithoutOptionalSubjectsInput {
  update: RegistrationUpdateWithoutOptionalSubjectsDataInput!
  create: RegistrationCreateWithoutOptionalSubjectsInput!
}

input RegistrationUpsertWithoutScoresInput {
  update: RegistrationUpdateWithoutScoresDataInput!
  create: RegistrationCreateWithoutScoresInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCandidateInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutCandidateDataInput!
  create: RegistrationCreateWithoutCandidateInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCenterExamSessionInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutCenterExamSessionDataInput!
  create: RegistrationCreateWithoutCenterExamSessionInput!
}

input RegistrationUpsertWithWhereUniqueWithoutCenterExamSessionSpecialtyInput {
  where: RegistrationWhereUniqueInput!
  update: RegistrationUpdateWithoutCenterExamSessionSpecialtyDataInput!
  create: RegistrationCreateWithoutCenterExamSessionSpecialtyInput!
}

input RegistrationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  candidate: CandidateWhereInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyWhereInput
  centerExamSession: CenterExamSessionWhereInput
  candExamSecretCode: String
  candExamSecretCode_not: String
  candExamSecretCode_in: [String!]
  candExamSecretCode_not_in: [String!]
  candExamSecretCode_lt: String
  candExamSecretCode_lte: String
  candExamSecretCode_gt: String
  candExamSecretCode_gte: String
  candExamSecretCode_contains: String
  candExamSecretCode_not_contains: String
  candExamSecretCode_starts_with: String
  candExamSecretCode_not_starts_with: String
  candExamSecretCode_ends_with: String
  candExamSecretCode_not_ends_with: String
  candExamSession: String
  candExamSession_not: String
  candExamSession_in: [String!]
  candExamSession_not_in: [String!]
  candExamSession_lt: String
  candExamSession_lte: String
  candExamSession_gt: String
  candExamSession_gte: String
  candExamSession_contains: String
  candExamSession_not_contains: String
  candExamSession_starts_with: String
  candExamSession_not_starts_with: String
  candExamSession_ends_with: String
  candExamSession_not_ends_with: String
  scores_every: ScoreWhereInput
  scores_some: ScoreWhereInput
  scores_none: ScoreWhereInput
  aptitude: String
  aptitude_not: String
  aptitude_in: [String!]
  aptitude_not_in: [String!]
  aptitude_lt: String
  aptitude_lte: String
  aptitude_gt: String
  aptitude_gte: String
  aptitude_contains: String
  aptitude_not_contains: String
  aptitude_starts_with: String
  aptitude_not_starts_with: String
  aptitude_ends_with: String
  aptitude_not_ends_with: String
  specialty: SpecialtyWhereInput
  optionalSubjects_every: RegisterOptionalSubjectWhereInput
  optionalSubjects_some: RegisterOptionalSubjectWhereInput
  optionalSubjects_none: RegisterOptionalSubjectWhereInput
  candRegistrationNumber: String
  candRegistrationNumber_not: String
  candRegistrationNumber_in: [String!]
  candRegistrationNumber_not_in: [String!]
  candRegistrationNumber_lt: String
  candRegistrationNumber_lte: String
  candRegistrationNumber_gt: String
  candRegistrationNumber_gte: String
  candRegistrationNumber_contains: String
  candRegistrationNumber_not_contains: String
  candRegistrationNumber_starts_with: String
  candRegistrationNumber_not_starts_with: String
  candRegistrationNumber_ends_with: String
  candRegistrationNumber_not_ends_with: String
  serial: Int
  serial_not: Int
  serial_in: [Int!]
  serial_not_in: [Int!]
  serial_lt: Int
  serial_lte: Int
  serial_gt: Int
  serial_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [RegistrationWhereInput!]
  OR: [RegistrationWhereInput!]
  NOT: [RegistrationWhereInput!]
}

input RegistrationWhereUniqueInput {
  id: ID
  candExamSecretCode: String
  candExamSession: String
  candRegistrationNumber: String
}

type Report {
  id: ID!
  reportName: String!
  centerExamSessionExaminer: CenterExamSessionExaminer!
  reportImage: String!
  user: User!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReportConnection {
  pageInfo: PageInfo!
  edges: [ReportEdge]!
  aggregate: AggregateReport!
}

input ReportCreateInput {
  reportName: String!
  centerExamSessionExaminer: CenterExamSessionExaminerCreateOneWithoutReportInput!
  reportImage: String!
  user: UserCreateOneInput!
}

input ReportCreateManyWithoutCenterExamSessionExaminerInput {
  create: [ReportCreateWithoutCenterExamSessionExaminerInput!]
  connect: [ReportWhereUniqueInput!]
}

input ReportCreateWithoutCenterExamSessionExaminerInput {
  reportName: String!
  reportImage: String!
  user: UserCreateOneInput!
}

type ReportEdge {
  node: Report!
  cursor: String!
}

enum ReportOrderByInput {
  id_ASC
  id_DESC
  reportName_ASC
  reportName_DESC
  reportImage_ASC
  reportImage_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ReportPreviousValues {
  id: ID!
  reportName: String!
  reportImage: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ReportSubscriptionPayload {
  mutation: MutationType!
  node: Report
  updatedFields: [String!]
  previousValues: ReportPreviousValues
}

input ReportSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ReportWhereInput
  AND: [ReportSubscriptionWhereInput!]
  OR: [ReportSubscriptionWhereInput!]
  NOT: [ReportSubscriptionWhereInput!]
}

input ReportUpdateInput {
  reportName: String
  centerExamSessionExaminer: CenterExamSessionExaminerUpdateOneRequiredWithoutReportInput
  reportImage: String
  user: UserUpdateOneRequiredInput
}

input ReportUpdateManyWithoutCenterExamSessionExaminerInput {
  create: [ReportCreateWithoutCenterExamSessionExaminerInput!]
  delete: [ReportWhereUniqueInput!]
  connect: [ReportWhereUniqueInput!]
  disconnect: [ReportWhereUniqueInput!]
  update: [ReportUpdateWithWhereUniqueWithoutCenterExamSessionExaminerInput!]
  upsert: [ReportUpsertWithWhereUniqueWithoutCenterExamSessionExaminerInput!]
}

input ReportUpdateWithoutCenterExamSessionExaminerDataInput {
  reportName: String
  reportImage: String
  user: UserUpdateOneRequiredInput
}

input ReportUpdateWithWhereUniqueWithoutCenterExamSessionExaminerInput {
  where: ReportWhereUniqueInput!
  data: ReportUpdateWithoutCenterExamSessionExaminerDataInput!
}

input ReportUpsertWithWhereUniqueWithoutCenterExamSessionExaminerInput {
  where: ReportWhereUniqueInput!
  update: ReportUpdateWithoutCenterExamSessionExaminerDataInput!
  create: ReportCreateWithoutCenterExamSessionExaminerInput!
}

input ReportWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  reportName: String
  reportName_not: String
  reportName_in: [String!]
  reportName_not_in: [String!]
  reportName_lt: String
  reportName_lte: String
  reportName_gt: String
  reportName_gte: String
  reportName_contains: String
  reportName_not_contains: String
  reportName_starts_with: String
  reportName_not_starts_with: String
  reportName_ends_with: String
  reportName_not_ends_with: String
  centerExamSessionExaminer: CenterExamSessionExaminerWhereInput
  reportImage: String
  reportImage_not: String
  reportImage_in: [String!]
  reportImage_not_in: [String!]
  reportImage_lt: String
  reportImage_lte: String
  reportImage_gt: String
  reportImage_gte: String
  reportImage_contains: String
  reportImage_not_contains: String
  reportImage_starts_with: String
  reportImage_not_starts_with: String
  reportImage_ends_with: String
  reportImage_not_ends_with: String
  user: UserWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ReportWhereInput!]
  OR: [ReportWhereInput!]
  NOT: [ReportWhereInput!]
}

input ReportWhereUniqueInput {
  id: ID
}

type Score {
  id: ID!
  subjectAve: Float
  subjectTotal: Float
  registration: Registration!
  subjectSpecialty: SubjectSpecialty!
  presence: Boolean
  coeff: Int!
  user: User!
  candExamSecretCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ScoreConnection {
  pageInfo: PageInfo!
  edges: [ScoreEdge]!
  aggregate: AggregateScore!
}

input ScoreCreateInput {
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationCreateOneWithoutScoresInput!
  subjectSpecialty: SubjectSpecialtyCreateOneInput!
  presence: Boolean
  coeff: Int!
  user: UserCreateOneInput!
  candExamSecretCode: String!
}

input ScoreCreateManyWithoutRegistrationInput {
  create: [ScoreCreateWithoutRegistrationInput!]
  connect: [ScoreWhereUniqueInput!]
}

input ScoreCreateWithoutRegistrationInput {
  subjectAve: Float
  subjectTotal: Float
  subjectSpecialty: SubjectSpecialtyCreateOneInput!
  presence: Boolean
  coeff: Int!
  user: UserCreateOneInput!
  candExamSecretCode: String!
}

type ScoreEdge {
  node: Score!
  cursor: String!
}

enum ScoreOrderByInput {
  id_ASC
  id_DESC
  subjectAve_ASC
  subjectAve_DESC
  subjectTotal_ASC
  subjectTotal_DESC
  presence_ASC
  presence_DESC
  coeff_ASC
  coeff_DESC
  candExamSecretCode_ASC
  candExamSecretCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type ScorePreviousValues {
  id: ID!
  subjectAve: Float
  subjectTotal: Float
  presence: Boolean
  coeff: Int!
  candExamSecretCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type ScoreSubscriptionPayload {
  mutation: MutationType!
  node: Score
  updatedFields: [String!]
  previousValues: ScorePreviousValues
}

input ScoreSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ScoreWhereInput
  AND: [ScoreSubscriptionWhereInput!]
  OR: [ScoreSubscriptionWhereInput!]
  NOT: [ScoreSubscriptionWhereInput!]
}

input ScoreUpdateInput {
  subjectAve: Float
  subjectTotal: Float
  registration: RegistrationUpdateOneRequiredWithoutScoresInput
  subjectSpecialty: SubjectSpecialtyUpdateOneRequiredInput
  presence: Boolean
  coeff: Int
  user: UserUpdateOneRequiredInput
  candExamSecretCode: String
}

input ScoreUpdateManyWithoutRegistrationInput {
  create: [ScoreCreateWithoutRegistrationInput!]
  delete: [ScoreWhereUniqueInput!]
  connect: [ScoreWhereUniqueInput!]
  disconnect: [ScoreWhereUniqueInput!]
  update: [ScoreUpdateWithWhereUniqueWithoutRegistrationInput!]
  upsert: [ScoreUpsertWithWhereUniqueWithoutRegistrationInput!]
}

input ScoreUpdateWithoutRegistrationDataInput {
  subjectAve: Float
  subjectTotal: Float
  subjectSpecialty: SubjectSpecialtyUpdateOneRequiredInput
  presence: Boolean
  coeff: Int
  user: UserUpdateOneRequiredInput
  candExamSecretCode: String
}

input ScoreUpdateWithWhereUniqueWithoutRegistrationInput {
  where: ScoreWhereUniqueInput!
  data: ScoreUpdateWithoutRegistrationDataInput!
}

input ScoreUpsertWithWhereUniqueWithoutRegistrationInput {
  where: ScoreWhereUniqueInput!
  update: ScoreUpdateWithoutRegistrationDataInput!
  create: ScoreCreateWithoutRegistrationInput!
}

input ScoreWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subjectAve: Float
  subjectAve_not: Float
  subjectAve_in: [Float!]
  subjectAve_not_in: [Float!]
  subjectAve_lt: Float
  subjectAve_lte: Float
  subjectAve_gt: Float
  subjectAve_gte: Float
  subjectTotal: Float
  subjectTotal_not: Float
  subjectTotal_in: [Float!]
  subjectTotal_not_in: [Float!]
  subjectTotal_lt: Float
  subjectTotal_lte: Float
  subjectTotal_gt: Float
  subjectTotal_gte: Float
  registration: RegistrationWhereInput
  subjectSpecialty: SubjectSpecialtyWhereInput
  presence: Boolean
  presence_not: Boolean
  coeff: Int
  coeff_not: Int
  coeff_in: [Int!]
  coeff_not_in: [Int!]
  coeff_lt: Int
  coeff_lte: Int
  coeff_gt: Int
  coeff_gte: Int
  user: UserWhereInput
  candExamSecretCode: String
  candExamSecretCode_not: String
  candExamSecretCode_in: [String!]
  candExamSecretCode_not_in: [String!]
  candExamSecretCode_lt: String
  candExamSecretCode_lte: String
  candExamSecretCode_gt: String
  candExamSecretCode_gte: String
  candExamSecretCode_contains: String
  candExamSecretCode_not_contains: String
  candExamSecretCode_starts_with: String
  candExamSecretCode_not_starts_with: String
  candExamSecretCode_ends_with: String
  candExamSecretCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [ScoreWhereInput!]
  OR: [ScoreWhereInput!]
  NOT: [ScoreWhereInput!]
}

input ScoreWhereUniqueInput {
  id: ID
}

type Session {
  id: ID!
  examSession(where: ExamSessionWhereInput, orderBy: ExamSessionOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ExamSession!]
  sessionName: String!
  sessionCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SessionConnection {
  pageInfo: PageInfo!
  edges: [SessionEdge]!
  aggregate: AggregateSession!
}

input SessionCreateInput {
  examSession: ExamSessionCreateManyWithoutSessionInput
  sessionName: String!
  sessionCode: String!
}

input SessionCreateOneWithoutExamSessionInput {
  create: SessionCreateWithoutExamSessionInput
  connect: SessionWhereUniqueInput
}

input SessionCreateWithoutExamSessionInput {
  sessionName: String!
  sessionCode: String!
}

type SessionEdge {
  node: Session!
  cursor: String!
}

enum SessionOrderByInput {
  id_ASC
  id_DESC
  sessionName_ASC
  sessionName_DESC
  sessionCode_ASC
  sessionCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SessionPreviousValues {
  id: ID!
  sessionName: String!
  sessionCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SessionSubscriptionPayload {
  mutation: MutationType!
  node: Session
  updatedFields: [String!]
  previousValues: SessionPreviousValues
}

input SessionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SessionWhereInput
  AND: [SessionSubscriptionWhereInput!]
  OR: [SessionSubscriptionWhereInput!]
  NOT: [SessionSubscriptionWhereInput!]
}

input SessionUpdateInput {
  examSession: ExamSessionUpdateManyWithoutSessionInput
  sessionName: String
  sessionCode: String
}

input SessionUpdateOneRequiredWithoutExamSessionInput {
  create: SessionCreateWithoutExamSessionInput
  update: SessionUpdateWithoutExamSessionDataInput
  upsert: SessionUpsertWithoutExamSessionInput
  connect: SessionWhereUniqueInput
}

input SessionUpdateWithoutExamSessionDataInput {
  sessionName: String
  sessionCode: String
}

input SessionUpsertWithoutExamSessionInput {
  update: SessionUpdateWithoutExamSessionDataInput!
  create: SessionCreateWithoutExamSessionInput!
}

input SessionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  examSession_every: ExamSessionWhereInput
  examSession_some: ExamSessionWhereInput
  examSession_none: ExamSessionWhereInput
  sessionName: String
  sessionName_not: String
  sessionName_in: [String!]
  sessionName_not_in: [String!]
  sessionName_lt: String
  sessionName_lte: String
  sessionName_gt: String
  sessionName_gte: String
  sessionName_contains: String
  sessionName_not_contains: String
  sessionName_starts_with: String
  sessionName_not_starts_with: String
  sessionName_ends_with: String
  sessionName_not_ends_with: String
  sessionCode: String
  sessionCode_not: String
  sessionCode_in: [String!]
  sessionCode_not_in: [String!]
  sessionCode_lt: String
  sessionCode_lte: String
  sessionCode_gt: String
  sessionCode_gte: String
  sessionCode_contains: String
  sessionCode_not_contains: String
  sessionCode_starts_with: String
  sessionCode_not_starts_with: String
  sessionCode_ends_with: String
  sessionCode_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SessionWhereInput!]
  OR: [SessionWhereInput!]
  NOT: [SessionWhereInput!]
}

input SessionWhereUniqueInput {
  id: ID
  sessionName: String
  sessionCode: String
}

type Specialty {
  id: ID!
  specialtyName: String!
  specialtyCode: String!
  subjectSpecialty(where: SubjectSpecialtyWhereInput, orderBy: SubjectSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubjectSpecialty!]
  centerExamSessionSpecialty(where: CenterExamSessionSpecialtyWhereInput, orderBy: CenterExamSessionSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [CenterExamSessionSpecialty!]
  createdAt: DateTime!
  updatedAt: DateTime!
  educationType: EducationType!
}

type SpecialtyConnection {
  pageInfo: PageInfo!
  edges: [SpecialtyEdge]!
  aggregate: AggregateSpecialty!
}

input SpecialtyCreateInput {
  specialtyName: String!
  specialtyCode: String!
  subjectSpecialty: SubjectSpecialtyCreateManyWithoutSpecialtyInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutSpecialtyInput
  educationType: EducationTypeCreateOneWithoutSpecialtyInput!
}

input SpecialtyCreateManyWithoutEducationTypeInput {
  create: [SpecialtyCreateWithoutEducationTypeInput!]
  connect: [SpecialtyWhereUniqueInput!]
}

input SpecialtyCreateOneInput {
  create: SpecialtyCreateInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyCreateOneWithoutCenterExamSessionSpecialtyInput {
  create: SpecialtyCreateWithoutCenterExamSessionSpecialtyInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyCreateOneWithoutSubjectSpecialtyInput {
  create: SpecialtyCreateWithoutSubjectSpecialtyInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyCreateWithoutCenterExamSessionSpecialtyInput {
  specialtyName: String!
  specialtyCode: String!
  subjectSpecialty: SubjectSpecialtyCreateManyWithoutSpecialtyInput
  educationType: EducationTypeCreateOneWithoutSpecialtyInput!
}

input SpecialtyCreateWithoutEducationTypeInput {
  specialtyName: String!
  specialtyCode: String!
  subjectSpecialty: SubjectSpecialtyCreateManyWithoutSpecialtyInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutSpecialtyInput
}

input SpecialtyCreateWithoutSubjectSpecialtyInput {
  specialtyName: String!
  specialtyCode: String!
  centerExamSessionSpecialty: CenterExamSessionSpecialtyCreateManyWithoutSpecialtyInput
  educationType: EducationTypeCreateOneWithoutSpecialtyInput!
}

type SpecialtyEdge {
  node: Specialty!
  cursor: String!
}

enum SpecialtyOrderByInput {
  id_ASC
  id_DESC
  specialtyName_ASC
  specialtyName_DESC
  specialtyCode_ASC
  specialtyCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SpecialtyPreviousValues {
  id: ID!
  specialtyName: String!
  specialtyCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SpecialtySubscriptionPayload {
  mutation: MutationType!
  node: Specialty
  updatedFields: [String!]
  previousValues: SpecialtyPreviousValues
}

input SpecialtySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SpecialtyWhereInput
  AND: [SpecialtySubscriptionWhereInput!]
  OR: [SpecialtySubscriptionWhereInput!]
  NOT: [SpecialtySubscriptionWhereInput!]
}

input SpecialtyUpdateDataInput {
  specialtyName: String
  specialtyCode: String
  subjectSpecialty: SubjectSpecialtyUpdateManyWithoutSpecialtyInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutSpecialtyInput
  educationType: EducationTypeUpdateOneRequiredWithoutSpecialtyInput
}

input SpecialtyUpdateInput {
  specialtyName: String
  specialtyCode: String
  subjectSpecialty: SubjectSpecialtyUpdateManyWithoutSpecialtyInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutSpecialtyInput
  educationType: EducationTypeUpdateOneRequiredWithoutSpecialtyInput
}

input SpecialtyUpdateManyWithoutEducationTypeInput {
  create: [SpecialtyCreateWithoutEducationTypeInput!]
  delete: [SpecialtyWhereUniqueInput!]
  connect: [SpecialtyWhereUniqueInput!]
  disconnect: [SpecialtyWhereUniqueInput!]
  update: [SpecialtyUpdateWithWhereUniqueWithoutEducationTypeInput!]
  upsert: [SpecialtyUpsertWithWhereUniqueWithoutEducationTypeInput!]
}

input SpecialtyUpdateOneRequiredInput {
  create: SpecialtyCreateInput
  update: SpecialtyUpdateDataInput
  upsert: SpecialtyUpsertNestedInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyUpdateOneRequiredWithoutCenterExamSessionSpecialtyInput {
  create: SpecialtyCreateWithoutCenterExamSessionSpecialtyInput
  update: SpecialtyUpdateWithoutCenterExamSessionSpecialtyDataInput
  upsert: SpecialtyUpsertWithoutCenterExamSessionSpecialtyInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyUpdateOneRequiredWithoutSubjectSpecialtyInput {
  create: SpecialtyCreateWithoutSubjectSpecialtyInput
  update: SpecialtyUpdateWithoutSubjectSpecialtyDataInput
  upsert: SpecialtyUpsertWithoutSubjectSpecialtyInput
  connect: SpecialtyWhereUniqueInput
}

input SpecialtyUpdateWithoutCenterExamSessionSpecialtyDataInput {
  specialtyName: String
  specialtyCode: String
  subjectSpecialty: SubjectSpecialtyUpdateManyWithoutSpecialtyInput
  educationType: EducationTypeUpdateOneRequiredWithoutSpecialtyInput
}

input SpecialtyUpdateWithoutEducationTypeDataInput {
  specialtyName: String
  specialtyCode: String
  subjectSpecialty: SubjectSpecialtyUpdateManyWithoutSpecialtyInput
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutSpecialtyInput
}

input SpecialtyUpdateWithoutSubjectSpecialtyDataInput {
  specialtyName: String
  specialtyCode: String
  centerExamSessionSpecialty: CenterExamSessionSpecialtyUpdateManyWithoutSpecialtyInput
  educationType: EducationTypeUpdateOneRequiredWithoutSpecialtyInput
}

input SpecialtyUpdateWithWhereUniqueWithoutEducationTypeInput {
  where: SpecialtyWhereUniqueInput!
  data: SpecialtyUpdateWithoutEducationTypeDataInput!
}

input SpecialtyUpsertNestedInput {
  update: SpecialtyUpdateDataInput!
  create: SpecialtyCreateInput!
}

input SpecialtyUpsertWithoutCenterExamSessionSpecialtyInput {
  update: SpecialtyUpdateWithoutCenterExamSessionSpecialtyDataInput!
  create: SpecialtyCreateWithoutCenterExamSessionSpecialtyInput!
}

input SpecialtyUpsertWithoutSubjectSpecialtyInput {
  update: SpecialtyUpdateWithoutSubjectSpecialtyDataInput!
  create: SpecialtyCreateWithoutSubjectSpecialtyInput!
}

input SpecialtyUpsertWithWhereUniqueWithoutEducationTypeInput {
  where: SpecialtyWhereUniqueInput!
  update: SpecialtyUpdateWithoutEducationTypeDataInput!
  create: SpecialtyCreateWithoutEducationTypeInput!
}

input SpecialtyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  specialtyName: String
  specialtyName_not: String
  specialtyName_in: [String!]
  specialtyName_not_in: [String!]
  specialtyName_lt: String
  specialtyName_lte: String
  specialtyName_gt: String
  specialtyName_gte: String
  specialtyName_contains: String
  specialtyName_not_contains: String
  specialtyName_starts_with: String
  specialtyName_not_starts_with: String
  specialtyName_ends_with: String
  specialtyName_not_ends_with: String
  specialtyCode: String
  specialtyCode_not: String
  specialtyCode_in: [String!]
  specialtyCode_not_in: [String!]
  specialtyCode_lt: String
  specialtyCode_lte: String
  specialtyCode_gt: String
  specialtyCode_gte: String
  specialtyCode_contains: String
  specialtyCode_not_contains: String
  specialtyCode_starts_with: String
  specialtyCode_not_starts_with: String
  specialtyCode_ends_with: String
  specialtyCode_not_ends_with: String
  subjectSpecialty_every: SubjectSpecialtyWhereInput
  subjectSpecialty_some: SubjectSpecialtyWhereInput
  subjectSpecialty_none: SubjectSpecialtyWhereInput
  centerExamSessionSpecialty_every: CenterExamSessionSpecialtyWhereInput
  centerExamSessionSpecialty_some: CenterExamSessionSpecialtyWhereInput
  centerExamSessionSpecialty_none: CenterExamSessionSpecialtyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  educationType: EducationTypeWhereInput
  AND: [SpecialtyWhereInput!]
  OR: [SpecialtyWhereInput!]
  NOT: [SpecialtyWhereInput!]
}

input SpecialtyWhereUniqueInput {
  id: ID
  specialtyCode: String
}

type SubDivision {
  id: ID!
  subDivName: String!
  subDivCode: String!
  division: Division!
  createdAt: DateTime!
  updatedAt: DateTime!
  town(where: TownWhereInput, orderBy: TownOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Town!]
}

type SubDivisionConnection {
  pageInfo: PageInfo!
  edges: [SubDivisionEdge]!
  aggregate: AggregateSubDivision!
}

input SubDivisionCreateInput {
  subDivName: String!
  subDivCode: String!
  division: DivisionCreateOneWithoutSubDivisionInput!
  town: TownCreateManyWithoutSubDivInput
}

input SubDivisionCreateManyWithoutDivisionInput {
  create: [SubDivisionCreateWithoutDivisionInput!]
  connect: [SubDivisionWhereUniqueInput!]
}

input SubDivisionCreateOneWithoutTownInput {
  create: SubDivisionCreateWithoutTownInput
  connect: SubDivisionWhereUniqueInput
}

input SubDivisionCreateWithoutDivisionInput {
  subDivName: String!
  subDivCode: String!
  town: TownCreateManyWithoutSubDivInput
}

input SubDivisionCreateWithoutTownInput {
  subDivName: String!
  subDivCode: String!
  division: DivisionCreateOneWithoutSubDivisionInput!
}

type SubDivisionEdge {
  node: SubDivision!
  cursor: String!
}

enum SubDivisionOrderByInput {
  id_ASC
  id_DESC
  subDivName_ASC
  subDivName_DESC
  subDivCode_ASC
  subDivCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubDivisionPreviousValues {
  id: ID!
  subDivName: String!
  subDivCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubDivisionSubscriptionPayload {
  mutation: MutationType!
  node: SubDivision
  updatedFields: [String!]
  previousValues: SubDivisionPreviousValues
}

input SubDivisionSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubDivisionWhereInput
  AND: [SubDivisionSubscriptionWhereInput!]
  OR: [SubDivisionSubscriptionWhereInput!]
  NOT: [SubDivisionSubscriptionWhereInput!]
}

input SubDivisionUpdateInput {
  subDivName: String
  subDivCode: String
  division: DivisionUpdateOneRequiredWithoutSubDivisionInput
  town: TownUpdateManyWithoutSubDivInput
}

input SubDivisionUpdateManyWithoutDivisionInput {
  create: [SubDivisionCreateWithoutDivisionInput!]
  delete: [SubDivisionWhereUniqueInput!]
  connect: [SubDivisionWhereUniqueInput!]
  disconnect: [SubDivisionWhereUniqueInput!]
  update: [SubDivisionUpdateWithWhereUniqueWithoutDivisionInput!]
  upsert: [SubDivisionUpsertWithWhereUniqueWithoutDivisionInput!]
}

input SubDivisionUpdateOneRequiredWithoutTownInput {
  create: SubDivisionCreateWithoutTownInput
  update: SubDivisionUpdateWithoutTownDataInput
  upsert: SubDivisionUpsertWithoutTownInput
  connect: SubDivisionWhereUniqueInput
}

input SubDivisionUpdateWithoutDivisionDataInput {
  subDivName: String
  subDivCode: String
  town: TownUpdateManyWithoutSubDivInput
}

input SubDivisionUpdateWithoutTownDataInput {
  subDivName: String
  subDivCode: String
  division: DivisionUpdateOneRequiredWithoutSubDivisionInput
}

input SubDivisionUpdateWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput!
  data: SubDivisionUpdateWithoutDivisionDataInput!
}

input SubDivisionUpsertWithoutTownInput {
  update: SubDivisionUpdateWithoutTownDataInput!
  create: SubDivisionCreateWithoutTownInput!
}

input SubDivisionUpsertWithWhereUniqueWithoutDivisionInput {
  where: SubDivisionWhereUniqueInput!
  update: SubDivisionUpdateWithoutDivisionDataInput!
  create: SubDivisionCreateWithoutDivisionInput!
}

input SubDivisionWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subDivName: String
  subDivName_not: String
  subDivName_in: [String!]
  subDivName_not_in: [String!]
  subDivName_lt: String
  subDivName_lte: String
  subDivName_gt: String
  subDivName_gte: String
  subDivName_contains: String
  subDivName_not_contains: String
  subDivName_starts_with: String
  subDivName_not_starts_with: String
  subDivName_ends_with: String
  subDivName_not_ends_with: String
  subDivCode: String
  subDivCode_not: String
  subDivCode_in: [String!]
  subDivCode_not_in: [String!]
  subDivCode_lt: String
  subDivCode_lte: String
  subDivCode_gt: String
  subDivCode_gte: String
  subDivCode_contains: String
  subDivCode_not_contains: String
  subDivCode_starts_with: String
  subDivCode_not_starts_with: String
  subDivCode_ends_with: String
  subDivCode_not_ends_with: String
  division: DivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  town_every: TownWhereInput
  town_some: TownWhereInput
  town_none: TownWhereInput
  AND: [SubDivisionWhereInput!]
  OR: [SubDivisionWhereInput!]
  NOT: [SubDivisionWhereInput!]
}

input SubDivisionWhereUniqueInput {
  id: ID
  subDivCode: String
}

type Subject {
  id: ID!
  subjectName: String!
  subjectCode: String!
  subjectType: String!
  subjectGroup: String!
  educType: EducationType!
  specialty(where: SubjectSpecialtyWhereInput, orderBy: SubjectSpecialtyOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [SubjectSpecialty!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubjectConnection {
  pageInfo: PageInfo!
  edges: [SubjectEdge]!
  aggregate: AggregateSubject!
}

input SubjectCreateInput {
  subjectName: String!
  subjectCode: String!
  subjectType: String!
  subjectGroup: String!
  educType: EducationTypeCreateOneWithoutSubjectInput!
  specialty: SubjectSpecialtyCreateManyWithoutSubjectInput
}

input SubjectCreateManyWithoutEducTypeInput {
  create: [SubjectCreateWithoutEducTypeInput!]
  connect: [SubjectWhereUniqueInput!]
}

input SubjectCreateOneInput {
  create: SubjectCreateInput
  connect: SubjectWhereUniqueInput
}

input SubjectCreateOneWithoutSpecialtyInput {
  create: SubjectCreateWithoutSpecialtyInput
  connect: SubjectWhereUniqueInput
}

input SubjectCreateWithoutEducTypeInput {
  subjectName: String!
  subjectCode: String!
  subjectType: String!
  subjectGroup: String!
  specialty: SubjectSpecialtyCreateManyWithoutSubjectInput
}

input SubjectCreateWithoutSpecialtyInput {
  subjectName: String!
  subjectCode: String!
  subjectType: String!
  subjectGroup: String!
  educType: EducationTypeCreateOneWithoutSubjectInput!
}

type SubjectEdge {
  node: Subject!
  cursor: String!
}

enum SubjectOrderByInput {
  id_ASC
  id_DESC
  subjectName_ASC
  subjectName_DESC
  subjectCode_ASC
  subjectCode_DESC
  subjectType_ASC
  subjectType_DESC
  subjectGroup_ASC
  subjectGroup_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type SubjectPreviousValues {
  id: ID!
  subjectName: String!
  subjectCode: String!
  subjectType: String!
  subjectGroup: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type SubjectSpecialty {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  specialty: Specialty!
  subject: Subject!
  coeff: Int!
}

type SubjectSpecialtyConnection {
  pageInfo: PageInfo!
  edges: [SubjectSpecialtyEdge]!
  aggregate: AggregateSubjectSpecialty!
}

input SubjectSpecialtyCreateInput {
  specialty: SpecialtyCreateOneWithoutSubjectSpecialtyInput!
  subject: SubjectCreateOneWithoutSpecialtyInput!
  coeff: Int!
}

input SubjectSpecialtyCreateManyWithoutSpecialtyInput {
  create: [SubjectSpecialtyCreateWithoutSpecialtyInput!]
  connect: [SubjectSpecialtyWhereUniqueInput!]
}

input SubjectSpecialtyCreateManyWithoutSubjectInput {
  create: [SubjectSpecialtyCreateWithoutSubjectInput!]
  connect: [SubjectSpecialtyWhereUniqueInput!]
}

input SubjectSpecialtyCreateOneInput {
  create: SubjectSpecialtyCreateInput
  connect: SubjectSpecialtyWhereUniqueInput
}

input SubjectSpecialtyCreateWithoutSpecialtyInput {
  subject: SubjectCreateOneWithoutSpecialtyInput!
  coeff: Int!
}

input SubjectSpecialtyCreateWithoutSubjectInput {
  specialty: SpecialtyCreateOneWithoutSubjectSpecialtyInput!
  coeff: Int!
}

type SubjectSpecialtyEdge {
  node: SubjectSpecialty!
  cursor: String!
}

enum SubjectSpecialtyOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
  coeff_ASC
  coeff_DESC
}

type SubjectSpecialtyPreviousValues {
  id: ID!
  createdAt: DateTime!
  updatedAt: DateTime!
  coeff: Int!
}

type SubjectSpecialtySubscriptionPayload {
  mutation: MutationType!
  node: SubjectSpecialty
  updatedFields: [String!]
  previousValues: SubjectSpecialtyPreviousValues
}

input SubjectSpecialtySubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectSpecialtyWhereInput
  AND: [SubjectSpecialtySubscriptionWhereInput!]
  OR: [SubjectSpecialtySubscriptionWhereInput!]
  NOT: [SubjectSpecialtySubscriptionWhereInput!]
}

input SubjectSpecialtyUpdateDataInput {
  specialty: SpecialtyUpdateOneRequiredWithoutSubjectSpecialtyInput
  subject: SubjectUpdateOneRequiredWithoutSpecialtyInput
  coeff: Int
}

input SubjectSpecialtyUpdateInput {
  specialty: SpecialtyUpdateOneRequiredWithoutSubjectSpecialtyInput
  subject: SubjectUpdateOneRequiredWithoutSpecialtyInput
  coeff: Int
}

input SubjectSpecialtyUpdateManyWithoutSpecialtyInput {
  create: [SubjectSpecialtyCreateWithoutSpecialtyInput!]
  delete: [SubjectSpecialtyWhereUniqueInput!]
  connect: [SubjectSpecialtyWhereUniqueInput!]
  disconnect: [SubjectSpecialtyWhereUniqueInput!]
  update: [SubjectSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput!]
  upsert: [SubjectSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput!]
}

input SubjectSpecialtyUpdateManyWithoutSubjectInput {
  create: [SubjectSpecialtyCreateWithoutSubjectInput!]
  delete: [SubjectSpecialtyWhereUniqueInput!]
  connect: [SubjectSpecialtyWhereUniqueInput!]
  disconnect: [SubjectSpecialtyWhereUniqueInput!]
  update: [SubjectSpecialtyUpdateWithWhereUniqueWithoutSubjectInput!]
  upsert: [SubjectSpecialtyUpsertWithWhereUniqueWithoutSubjectInput!]
}

input SubjectSpecialtyUpdateOneRequiredInput {
  create: SubjectSpecialtyCreateInput
  update: SubjectSpecialtyUpdateDataInput
  upsert: SubjectSpecialtyUpsertNestedInput
  connect: SubjectSpecialtyWhereUniqueInput
}

input SubjectSpecialtyUpdateWithoutSpecialtyDataInput {
  subject: SubjectUpdateOneRequiredWithoutSpecialtyInput
  coeff: Int
}

input SubjectSpecialtyUpdateWithoutSubjectDataInput {
  specialty: SpecialtyUpdateOneRequiredWithoutSubjectSpecialtyInput
  coeff: Int
}

input SubjectSpecialtyUpdateWithWhereUniqueWithoutSpecialtyInput {
  where: SubjectSpecialtyWhereUniqueInput!
  data: SubjectSpecialtyUpdateWithoutSpecialtyDataInput!
}

input SubjectSpecialtyUpdateWithWhereUniqueWithoutSubjectInput {
  where: SubjectSpecialtyWhereUniqueInput!
  data: SubjectSpecialtyUpdateWithoutSubjectDataInput!
}

input SubjectSpecialtyUpsertNestedInput {
  update: SubjectSpecialtyUpdateDataInput!
  create: SubjectSpecialtyCreateInput!
}

input SubjectSpecialtyUpsertWithWhereUniqueWithoutSpecialtyInput {
  where: SubjectSpecialtyWhereUniqueInput!
  update: SubjectSpecialtyUpdateWithoutSpecialtyDataInput!
  create: SubjectSpecialtyCreateWithoutSpecialtyInput!
}

input SubjectSpecialtyUpsertWithWhereUniqueWithoutSubjectInput {
  where: SubjectSpecialtyWhereUniqueInput!
  update: SubjectSpecialtyUpdateWithoutSubjectDataInput!
  create: SubjectSpecialtyCreateWithoutSubjectInput!
}

input SubjectSpecialtyWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  specialty: SpecialtyWhereInput
  subject: SubjectWhereInput
  coeff: Int
  coeff_not: Int
  coeff_in: [Int!]
  coeff_not_in: [Int!]
  coeff_lt: Int
  coeff_lte: Int
  coeff_gt: Int
  coeff_gte: Int
  AND: [SubjectSpecialtyWhereInput!]
  OR: [SubjectSpecialtyWhereInput!]
  NOT: [SubjectSpecialtyWhereInput!]
}

input SubjectSpecialtyWhereUniqueInput {
  id: ID
}

type SubjectSubscriptionPayload {
  mutation: MutationType!
  node: Subject
  updatedFields: [String!]
  previousValues: SubjectPreviousValues
}

input SubjectSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: SubjectWhereInput
  AND: [SubjectSubscriptionWhereInput!]
  OR: [SubjectSubscriptionWhereInput!]
  NOT: [SubjectSubscriptionWhereInput!]
}

input SubjectUpdateDataInput {
  subjectName: String
  subjectCode: String
  subjectType: String
  subjectGroup: String
  educType: EducationTypeUpdateOneRequiredWithoutSubjectInput
  specialty: SubjectSpecialtyUpdateManyWithoutSubjectInput
}

input SubjectUpdateInput {
  subjectName: String
  subjectCode: String
  subjectType: String
  subjectGroup: String
  educType: EducationTypeUpdateOneRequiredWithoutSubjectInput
  specialty: SubjectSpecialtyUpdateManyWithoutSubjectInput
}

input SubjectUpdateManyWithoutEducTypeInput {
  create: [SubjectCreateWithoutEducTypeInput!]
  delete: [SubjectWhereUniqueInput!]
  connect: [SubjectWhereUniqueInput!]
  disconnect: [SubjectWhereUniqueInput!]
  update: [SubjectUpdateWithWhereUniqueWithoutEducTypeInput!]
  upsert: [SubjectUpsertWithWhereUniqueWithoutEducTypeInput!]
}

input SubjectUpdateOneRequiredInput {
  create: SubjectCreateInput
  update: SubjectUpdateDataInput
  upsert: SubjectUpsertNestedInput
  connect: SubjectWhereUniqueInput
}

input SubjectUpdateOneRequiredWithoutSpecialtyInput {
  create: SubjectCreateWithoutSpecialtyInput
  update: SubjectUpdateWithoutSpecialtyDataInput
  upsert: SubjectUpsertWithoutSpecialtyInput
  connect: SubjectWhereUniqueInput
}

input SubjectUpdateWithoutEducTypeDataInput {
  subjectName: String
  subjectCode: String
  subjectType: String
  subjectGroup: String
  specialty: SubjectSpecialtyUpdateManyWithoutSubjectInput
}

input SubjectUpdateWithoutSpecialtyDataInput {
  subjectName: String
  subjectCode: String
  subjectType: String
  subjectGroup: String
  educType: EducationTypeUpdateOneRequiredWithoutSubjectInput
}

input SubjectUpdateWithWhereUniqueWithoutEducTypeInput {
  where: SubjectWhereUniqueInput!
  data: SubjectUpdateWithoutEducTypeDataInput!
}

input SubjectUpsertNestedInput {
  update: SubjectUpdateDataInput!
  create: SubjectCreateInput!
}

input SubjectUpsertWithoutSpecialtyInput {
  update: SubjectUpdateWithoutSpecialtyDataInput!
  create: SubjectCreateWithoutSpecialtyInput!
}

input SubjectUpsertWithWhereUniqueWithoutEducTypeInput {
  where: SubjectWhereUniqueInput!
  update: SubjectUpdateWithoutEducTypeDataInput!
  create: SubjectCreateWithoutEducTypeInput!
}

input SubjectWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  subjectName: String
  subjectName_not: String
  subjectName_in: [String!]
  subjectName_not_in: [String!]
  subjectName_lt: String
  subjectName_lte: String
  subjectName_gt: String
  subjectName_gte: String
  subjectName_contains: String
  subjectName_not_contains: String
  subjectName_starts_with: String
  subjectName_not_starts_with: String
  subjectName_ends_with: String
  subjectName_not_ends_with: String
  subjectCode: String
  subjectCode_not: String
  subjectCode_in: [String!]
  subjectCode_not_in: [String!]
  subjectCode_lt: String
  subjectCode_lte: String
  subjectCode_gt: String
  subjectCode_gte: String
  subjectCode_contains: String
  subjectCode_not_contains: String
  subjectCode_starts_with: String
  subjectCode_not_starts_with: String
  subjectCode_ends_with: String
  subjectCode_not_ends_with: String
  subjectType: String
  subjectType_not: String
  subjectType_in: [String!]
  subjectType_not_in: [String!]
  subjectType_lt: String
  subjectType_lte: String
  subjectType_gt: String
  subjectType_gte: String
  subjectType_contains: String
  subjectType_not_contains: String
  subjectType_starts_with: String
  subjectType_not_starts_with: String
  subjectType_ends_with: String
  subjectType_not_ends_with: String
  subjectGroup: String
  subjectGroup_not: String
  subjectGroup_in: [String!]
  subjectGroup_not_in: [String!]
  subjectGroup_lt: String
  subjectGroup_lte: String
  subjectGroup_gt: String
  subjectGroup_gte: String
  subjectGroup_contains: String
  subjectGroup_not_contains: String
  subjectGroup_starts_with: String
  subjectGroup_not_starts_with: String
  subjectGroup_ends_with: String
  subjectGroup_not_ends_with: String
  educType: EducationTypeWhereInput
  specialty_every: SubjectSpecialtyWhereInput
  specialty_some: SubjectSpecialtyWhereInput
  specialty_none: SubjectSpecialtyWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [SubjectWhereInput!]
  OR: [SubjectWhereInput!]
  NOT: [SubjectWhereInput!]
}

input SubjectWhereUniqueInput {
  id: ID
  subjectName: String
  subjectCode: String
}

type Subscription {
  candidate(where: CandidateSubscriptionWhereInput): CandidateSubscriptionPayload
  center(where: CenterSubscriptionWhereInput): CenterSubscriptionPayload
  centerExamSession(where: CenterExamSessionSubscriptionWhereInput): CenterExamSessionSubscriptionPayload
  centerExamSessionExaminer(where: CenterExamSessionExaminerSubscriptionWhereInput): CenterExamSessionExaminerSubscriptionPayload
  centerExamSessionSpecialty(where: CenterExamSessionSpecialtySubscriptionWhereInput): CenterExamSessionSpecialtySubscriptionPayload
  division(where: DivisionSubscriptionWhereInput): DivisionSubscriptionPayload
  educationType(where: EducationTypeSubscriptionWhereInput): EducationTypeSubscriptionPayload
  exam(where: ExamSubscriptionWhereInput): ExamSubscriptionPayload
  examSession(where: ExamSessionSubscriptionWhereInput): ExamSessionSubscriptionPayload
  examiner(where: ExaminerSubscriptionWhereInput): ExaminerSubscriptionPayload
  phase(where: PhaseSubscriptionWhereInput): PhaseSubscriptionPayload
  phaseRank(where: PhaseRankSubscriptionWhereInput): PhaseRankSubscriptionPayload
  rank(where: RankSubscriptionWhereInput): RankSubscriptionPayload
  region(where: RegionSubscriptionWhereInput): RegionSubscriptionPayload
  registerOptionalSubject(where: RegisterOptionalSubjectSubscriptionWhereInput): RegisterOptionalSubjectSubscriptionPayload
  registration(where: RegistrationSubscriptionWhereInput): RegistrationSubscriptionPayload
  report(where: ReportSubscriptionWhereInput): ReportSubscriptionPayload
  score(where: ScoreSubscriptionWhereInput): ScoreSubscriptionPayload
  session(where: SessionSubscriptionWhereInput): SessionSubscriptionPayload
  specialty(where: SpecialtySubscriptionWhereInput): SpecialtySubscriptionPayload
  subDivision(where: SubDivisionSubscriptionWhereInput): SubDivisionSubscriptionPayload
  subject(where: SubjectSubscriptionWhereInput): SubjectSubscriptionPayload
  subjectSpecialty(where: SubjectSpecialtySubscriptionWhereInput): SubjectSpecialtySubscriptionPayload
  town(where: TownSubscriptionWhereInput): TownSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Town {
  id: ID!
  townName: String!
  townCode: String!
  subDiv: SubDivision!
  createdAt: DateTime!
  updatedAt: DateTime!
  center(where: CenterWhereInput, orderBy: CenterOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Center!]
}

type TownConnection {
  pageInfo: PageInfo!
  edges: [TownEdge]!
  aggregate: AggregateTown!
}

input TownCreateInput {
  townName: String!
  townCode: String!
  subDiv: SubDivisionCreateOneWithoutTownInput!
  center: CenterCreateManyWithoutTownInput
}

input TownCreateManyWithoutSubDivInput {
  create: [TownCreateWithoutSubDivInput!]
  connect: [TownWhereUniqueInput!]
}

input TownCreateOneWithoutCenterInput {
  create: TownCreateWithoutCenterInput
  connect: TownWhereUniqueInput
}

input TownCreateWithoutCenterInput {
  townName: String!
  townCode: String!
  subDiv: SubDivisionCreateOneWithoutTownInput!
}

input TownCreateWithoutSubDivInput {
  townName: String!
  townCode: String!
  center: CenterCreateManyWithoutTownInput
}

type TownEdge {
  node: Town!
  cursor: String!
}

enum TownOrderByInput {
  id_ASC
  id_DESC
  townName_ASC
  townName_DESC
  townCode_ASC
  townCode_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type TownPreviousValues {
  id: ID!
  townName: String!
  townCode: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type TownSubscriptionPayload {
  mutation: MutationType!
  node: Town
  updatedFields: [String!]
  previousValues: TownPreviousValues
}

input TownSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: TownWhereInput
  AND: [TownSubscriptionWhereInput!]
  OR: [TownSubscriptionWhereInput!]
  NOT: [TownSubscriptionWhereInput!]
}

input TownUpdateInput {
  townName: String
  townCode: String
  subDiv: SubDivisionUpdateOneRequiredWithoutTownInput
  center: CenterUpdateManyWithoutTownInput
}

input TownUpdateManyWithoutSubDivInput {
  create: [TownCreateWithoutSubDivInput!]
  delete: [TownWhereUniqueInput!]
  connect: [TownWhereUniqueInput!]
  disconnect: [TownWhereUniqueInput!]
  update: [TownUpdateWithWhereUniqueWithoutSubDivInput!]
  upsert: [TownUpsertWithWhereUniqueWithoutSubDivInput!]
}

input TownUpdateOneRequiredWithoutCenterInput {
  create: TownCreateWithoutCenterInput
  update: TownUpdateWithoutCenterDataInput
  upsert: TownUpsertWithoutCenterInput
  connect: TownWhereUniqueInput
}

input TownUpdateWithoutCenterDataInput {
  townName: String
  townCode: String
  subDiv: SubDivisionUpdateOneRequiredWithoutTownInput
}

input TownUpdateWithoutSubDivDataInput {
  townName: String
  townCode: String
  center: CenterUpdateManyWithoutTownInput
}

input TownUpdateWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput!
  data: TownUpdateWithoutSubDivDataInput!
}

input TownUpsertWithoutCenterInput {
  update: TownUpdateWithoutCenterDataInput!
  create: TownCreateWithoutCenterInput!
}

input TownUpsertWithWhereUniqueWithoutSubDivInput {
  where: TownWhereUniqueInput!
  update: TownUpdateWithoutSubDivDataInput!
  create: TownCreateWithoutSubDivInput!
}

input TownWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  townName: String
  townName_not: String
  townName_in: [String!]
  townName_not_in: [String!]
  townName_lt: String
  townName_lte: String
  townName_gt: String
  townName_gte: String
  townName_contains: String
  townName_not_contains: String
  townName_starts_with: String
  townName_not_starts_with: String
  townName_ends_with: String
  townName_not_ends_with: String
  townCode: String
  townCode_not: String
  townCode_in: [String!]
  townCode_not_in: [String!]
  townCode_lt: String
  townCode_lte: String
  townCode_gt: String
  townCode_gte: String
  townCode_contains: String
  townCode_not_contains: String
  townCode_starts_with: String
  townCode_not_starts_with: String
  townCode_ends_with: String
  townCode_not_ends_with: String
  subDiv: SubDivisionWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  center_every: CenterWhereInput
  center_some: CenterWhereInput
  center_none: CenterWhereInput
  AND: [TownWhereInput!]
  OR: [TownWhereInput!]
  NOT: [TownWhereInput!]
}

input TownWhereUniqueInput {
  id: ID
  townCode: String
}

type User {
  id: ID!
  email: String!
  name: String!
  password: String!
  resetToken: String
  resetTokenExpiry: String
  candidate: Candidate
  permissions: [Permissions!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  email: String!
  name: String!
  password: String!
  resetToken: String
  resetTokenExpiry: String
  candidate: CandidateCreateOneWithoutUserInput
  permissions: UserCreatepermissionsInput
}

input UserCreateOneInput {
  create: UserCreateInput
  connect: UserWhereUniqueInput
}

input UserCreateOneWithoutCandidateInput {
  create: UserCreateWithoutCandidateInput
  connect: UserWhereUniqueInput
}

input UserCreatepermissionsInput {
  set: [Permissions!]
}

input UserCreateWithoutCandidateInput {
  email: String!
  name: String!
  password: String!
  resetToken: String
  resetTokenExpiry: String
  permissions: UserCreatepermissionsInput
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  name_ASC
  name_DESC
  password_ASC
  password_DESC
  resetToken_ASC
  resetToken_DESC
  resetTokenExpiry_ASC
  resetTokenExpiry_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  name: String!
  password: String!
  resetToken: String
  resetTokenExpiry: String
  permissions: [Permissions!]!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateDataInput {
  email: String
  name: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  candidate: CandidateUpdateOneWithoutUserInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateInput {
  email: String
  name: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  candidate: CandidateUpdateOneWithoutUserInput
  permissions: UserUpdatepermissionsInput
}

input UserUpdateOneRequiredInput {
  create: UserCreateInput
  update: UserUpdateDataInput
  upsert: UserUpsertNestedInput
  connect: UserWhereUniqueInput
}

input UserUpdateOneRequiredWithoutCandidateInput {
  create: UserCreateWithoutCandidateInput
  update: UserUpdateWithoutCandidateDataInput
  upsert: UserUpsertWithoutCandidateInput
  connect: UserWhereUniqueInput
}

input UserUpdatepermissionsInput {
  set: [Permissions!]
}

input UserUpdateWithoutCandidateDataInput {
  email: String
  name: String
  password: String
  resetToken: String
  resetTokenExpiry: String
  permissions: UserUpdatepermissionsInput
}

input UserUpsertNestedInput {
  update: UserUpdateDataInput!
  create: UserCreateInput!
}

input UserUpsertWithoutCandidateInput {
  update: UserUpdateWithoutCandidateDataInput!
  create: UserCreateWithoutCandidateInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  resetToken: String
  resetToken_not: String
  resetToken_in: [String!]
  resetToken_not_in: [String!]
  resetToken_lt: String
  resetToken_lte: String
  resetToken_gt: String
  resetToken_gte: String
  resetToken_contains: String
  resetToken_not_contains: String
  resetToken_starts_with: String
  resetToken_not_starts_with: String
  resetToken_ends_with: String
  resetToken_not_ends_with: String
  resetTokenExpiry: String
  resetTokenExpiry_not: String
  resetTokenExpiry_in: [String!]
  resetTokenExpiry_not_in: [String!]
  resetTokenExpiry_lt: String
  resetTokenExpiry_lte: String
  resetTokenExpiry_gt: String
  resetTokenExpiry_gte: String
  resetTokenExpiry_contains: String
  resetTokenExpiry_not_contains: String
  resetTokenExpiry_starts_with: String
  resetTokenExpiry_not_starts_with: String
  resetTokenExpiry_ends_with: String
  resetTokenExpiry_not_ends_with: String
  candidate: CandidateWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
